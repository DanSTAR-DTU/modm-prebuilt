<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>modm: Assertions and Abandonment</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">modm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Assertions and Abandonment<div class="ingroups"><a class="el" href="group__modm__architecture.html">Architecture Interfaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:structmodm_1_1_assertion_info"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__assert.html#structmodm_1_1_assertion_info">modm::AssertionInfo</a></td></tr>
<tr class="separator:structmodm_1_1_assertion_info"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga59aff3dc76bdef1ddf77ab269520c6a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__assert.html#ga59aff3dc76bdef1ddf77ab269520c6a5">MODM_ASSERTION_INFO_HAS_DESCRIPTION</a>&#160;&#160;&#160;0/1</td></tr>
<tr class="separator:ga59aff3dc76bdef1ddf77ab269520c6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16bc9b4ebefe47d1417ec75f99b30ee6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__assert.html#ga16bc9b4ebefe47d1417ec75f99b30ee6">MODM_ASSERTION_HANDLER</a>(handler)</td></tr>
<tr class="separator:ga16bc9b4ebefe47d1417ec75f99b30ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59f386a6fa7042bb1bcddbee5e9e7909"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__assert.html#ga59f386a6fa7042bb1bcddbee5e9e7909">MODM_ASSERTION_HANDLER_DEBUG</a>(handler)</td></tr>
<tr class="separator:ga59f386a6fa7042bb1bcddbee5e9e7909"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf2a1c6bb3af678b68ad976a75cb1208c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__assert.html#gaf2a1c6bb3af678b68ad976a75cb1208c">modm::AbandonmentBehavior</a> = <a class="el" href="group__modm__architecture__register.html#gacdf81ef59f08411232bb3e7c8be57762">Flags8</a>&lt; <a class="el" href="group__modm__architecture__assert.html#gaf22c76f51642c50723ba439c5e080726">Abandonment</a> &gt;</td></tr>
<tr class="separator:gaf2a1c6bb3af678b68ad976a75cb1208c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga099140ec060a79b18029530dd05c2003"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__assert.html#ga099140ec060a79b18029530dd05c2003">modm::AssertionHandler</a> = <a class="el" href="group__modm__architecture__assert.html#gaf22c76f51642c50723ba439c5e080726">Abandonment</a>(*)(const <a class="el" href="group__modm__architecture__assert.html#structmodm_1_1_assertion_info">AssertionInfo</a> &amp;info)</td></tr>
<tr class="separator:ga099140ec060a79b18029530dd05c2003"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaf22c76f51642c50723ba439c5e080726"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__assert.html#gaf22c76f51642c50723ba439c5e080726">modm::Abandonment</a> : uint8_t { <a class="el" href="group__modm__architecture__assert.html#ggaf22c76f51642c50723ba439c5e080726a60a3629ef6a8f991f45d7a85f2458544">modm::Abandonment::DontCare</a> = Bit0, 
<a class="el" href="group__modm__architecture__assert.html#ggaf22c76f51642c50723ba439c5e080726afd038fc7f319e48f3115d92bf5bdbef9">modm::Abandonment::Ignore</a> = Bit1, 
<a class="el" href="group__modm__architecture__assert.html#ggaf22c76f51642c50723ba439c5e080726aceaa0734f0b3c738120c67344d8f3ec1">modm::Abandonment::Fail</a> = Bit2, 
<a class="el" href="group__modm__architecture__assert.html#ggaf22c76f51642c50723ba439c5e080726aa603905470e2a5b8c13e96b579ef0dba">modm::Abandonment::Debug</a> = Bit7
 }</td></tr>
<tr class="separator:gaf22c76f51642c50723ba439c5e080726"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga13c92d3667401cbe959c82d9eea6ea9f"><td class="memItemLeft" align="right" valign="top">modm_noreturn void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__assert.html#ga13c92d3667401cbe959c82d9eea6ea9f">modm_assert</a> (bool condition, const char *name, const char *description, uintptr_t context=uintptr_t(-1))</td></tr>
<tr class="separator:ga13c92d3667401cbe959c82d9eea6ea9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb9269522e0d94f5aacb0ab903afeb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__assert.html#gadfb9269522e0d94f5aacb0ab903afeb0">modm_assert_continue_fail</a> (bool condition, const char *name, const char *description, uintptr_t context=uintptr_t(-1))</td></tr>
<tr class="separator:gadfb9269522e0d94f5aacb0ab903afeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0afeca111ac7a7edf74cae31a57b7591"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__assert.html#ga0afeca111ac7a7edf74cae31a57b7591">modm_assert_continue_ignore</a> (bool condition, const char *name, const char *description, uintptr_t context=uintptr_t(-1))</td></tr>
<tr class="separator:ga0afeca111ac7a7edf74cae31a57b7591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ad3e2d57cd337bf25a1f0c8601d9b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__assert.html#ga04ad3e2d57cd337bf25a1f0c8601d9b0">modm_assert_continue_fail_debug</a> (bool condition, const char *name, const char *description, uintptr_t context=uintptr_t(-1))</td></tr>
<tr class="separator:ga04ad3e2d57cd337bf25a1f0c8601d9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeddecc3fccc43849b042733cd4d42c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__assert.html#gafeddecc3fccc43849b042733cd4d42c6">modm_assert_continue_ignore_debug</a> (bool condition, const char *name, const char *description, uintptr_t context=uintptr_t(-1))</td></tr>
<tr class="separator:gafeddecc3fccc43849b042733cd4d42c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadef5785a7de8bb855ffde663d2e09e70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__architecture__assert.html#gadef5785a7de8bb855ffde663d2e09e70">modm_abandon</a> (const <a class="el" href="group__modm__architecture__assert.html#structmodm_1_1_assertion_info">modm::AssertionInfo</a> &amp;info) <a class="el" href="group__modm__architecture.html#gabcab3f4f9780bbcdf978319c34084eb9">modm_weak</a></td></tr>
<tr class="separator:gadef5785a7de8bb855ffde663d2e09e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>lbuild module: <code>modm:architecture:assert</code></p>
<p>This module provides a way to define and report assertions, that act as a low-cost replacement for C++ exceptions and as a low-cost customization point for errors raised in asynchronous code.</p>
<p>Assertions are called with or without a context:</p>
<ul>
<li><code>modm_assert(condition, name, descr);</code></li>
<li><code>modm_assert(condition, name, descr, context);</code></li>
</ul>
<p>They have the following arguments:</p>
<ol type="1">
<li><code>bool condition</code>: The assertion fails when this condition evaluated to false.</li>
<li><code>const char *name</code>: A short and unique assertion name.</li>
<li><code>const char *description</code>: A detailed description of the failure.</li>
<li><code>uintptr_t context = -1</code>: Optional context.</li>
</ol>
<p>The condition is evaluated at most once by a (C-style) cast to bool.</p>
<p>The name format is not enforced, however, it is recommended to either use <code>what</code> for top-level failures, like <code>malloc</code> for heap troubles, or <code>scope.what</code> for failures that may not be unique, like <code>can.rx</code> vs. <code>uart.rx</code> for when their respective receive buffers overflow.</p>
<p>The description can be as detailed as necessary, since it is only included in the firmware if the <code>with_description</code> option is set to true, which also defines <code>MODM_ASSERTION_INFO_HAS_DESCRIPTION</code> to 1 or 0. You can either find the detailed description in your code via its name, or if you prefer a stand-alone solution and your target has enough memory, include all strings in your binary.</p>
<p>The context is of pointer size, and anything passed to it is cast to <code>uintptr_t</code>. Otherwise all bits are set via <code>uintptr_t(-1)</code>.</p>
<p>Assertions are implemented as macros and expand to this pseudo-code equivalent:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__modm__architecture__assert.html#ga13c92d3667401cbe959c82d9eea6ea9f">modm_assert</a>(<span class="keywordtype">bool</span> condition, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *description,</div><div class="line">                 uintptr_t context=uintptr_t(-1))</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (not condition)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__modm__architecture__assert.html#structmodm_1_1_assertion_info">modm::AssertionInfo</a> <a class="code" href="namespacemodm_1_1log.html#a9c4f35b0f684671a61be871f3c72a5b4">info</a>{name, description, context};</div><div class="line">        modm_assert_report(<a class="code" href="namespacemodm_1_1log.html#a9c4f35b0f684671a61be871f3c72a5b4">info</a>);</div><div class="line">        <span class="comment">// Unreachable code</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>"Assertions can be used in both C and C++ code."</dd></dl>
<p>If you like to know the technical details, you can <a href="https://blog.salkinium.com/xpccs-error-model">read here about the original assertions in xpcc</a>.</p>
<h2>Assertion Handlers</h2>
<p>Assertions may also be recoverable if the call site allows for it. For example if the CAN receive buffer overflows, you may want to simply discard the input. If malloc fails to allocate it just returns NULL and the caller is responsible to deal with that. But maybe you want to enable an additional assertion in debug mode just to double-check.</p>
<p>When an assertion fails, the runtime calls any number of user-defined handlers, registered using <code><a class="el" href="group__modm__architecture__assert.html#ga16bc9b4ebefe47d1417ec75f99b30ee6">MODM_ASSERTION_HANDLER(handler)</a></code>. The handlers must return a <code><a class="el" href="group__modm__architecture__assert.html#gaf22c76f51642c50723ba439c5e080726">modm::Abandonment</a></code> value, specifing whether they want to continue with the execution with <code>Abandonment::Ignore</code>, or abandon execution with <code>Abandonment::Fail</code> leading to a call to <code>modm_abandon(info)</code>, or delegate the decision with <code>Abandonment::DontCare</code>.</p>
<p>For example, this neutral handler logs the failed assertion's name, but delegates all further decisions to others:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="group__modm__architecture__assert.html#gaf22c76f51642c50723ba439c5e080726">modm::Abandonment</a></div><div class="line">log_assertion(<span class="keyword">const</span> <a class="code" href="group__modm__architecture__assert.html#structmodm_1_1_assertion_info">modm::AssertionInfo</a> &amp;<a class="code" href="namespacemodm_1_1log.html#a9c4f35b0f684671a61be871f3c72a5b4">info</a>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__modm__debug.html#gadf3ebf7b7d086653da99e9a5db3e72f2">MODM_LOG_ERROR</a>.printf(<span class="stringliteral">&quot;Assertion &#39;%s&#39; raised!\n&quot;</span>, <a class="code" href="namespacemodm_1_1log.html#a9c4f35b0f684671a61be871f3c72a5b4">info</a>.name);</div><div class="line">    <span class="keywordflow">return</span> Abandonment::DontCare;</div><div class="line">}</div><div class="line"><span class="comment">// Register handler for all builds</span></div><div class="line"><a class="code" href="group__modm__architecture__assert.html#ga16bc9b4ebefe47d1417ec75f99b30ee6">MODM_ASSERTION_HANDLER</a>(log_assertion);</div><div class="line"><span class="comment">// Or register only for debug builds</span></div><div class="line"><a class="code" href="group__modm__architecture__assert.html#ga59f386a6fa7042bb1bcddbee5e9e7909">MODM_ASSERTION_HANDLER_DEBUG</a>(log_assertion);</div></div><!-- fragment --><p>You may register specialized handlers anywhere in your code, for example for ignoring the mentioned CAN receive buffer overflow in your connectivity code:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="group__modm__architecture__assert.html#gaf22c76f51642c50723ba439c5e080726">modm::Abandonment</a></div><div class="line">ignore_can_rx_handler(<span class="keyword">const</span> <a class="code" href="group__modm__architecture__assert.html#structmodm_1_1_assertion_info">modm::AssertionInfo</a> &amp;<a class="code" href="namespacemodm_1_1log.html#a9c4f35b0f684671a61be871f3c72a5b4">info</a>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="namespacemodm_1_1log.html#a9c4f35b0f684671a61be871f3c72a5b4">info</a>.name == <span class="stringliteral">&quot;can.rx&quot;</span>s) {</div><div class="line">        <span class="comment">// Only silently ignore this specific assertion!</span></div><div class="line">        <span class="keywordflow">return</span> Abandonment::Ignore;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> Abandonment::DontCare;</div><div class="line">}</div><div class="line"><a class="code" href="group__modm__architecture__assert.html#ga16bc9b4ebefe47d1417ec75f99b30ee6">MODM_ASSERTION_HANDLER</a>(ignore_can_rx_handler);</div></div><!-- fragment --><p>You may define any number of handlers, which are called in random order by the runtime and their results are accumulated as follows:</p>
<ol type="1">
<li>If at least one handler returns <code>Abandonment::Fail</code> execution abandons.</li>
<li>Otherwise if any handler returns <code>Abandonment::Ignore</code> execution resumes.</li>
<li>Otherwise if no handlers are registered or all handlers return <code>Abandonment::DontCare</code>, the assertion type determines the outcome.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>"Handler execution order is undefined." The order of handler execution is undefined and must not be relied upon for any functionality!</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>"Assertions and handlers are not reentrant!" Assertions may fail in an interrupt context, thus calling handlers in that context too. Since handlers may make use of interrupts themselves (for logging via UART) assertions are not atomically scoped by default. You may however use a <code><a class="el" href="classmodm_1_1atomic_1_1_lock.html">modm::atomic::Lock</a></code> inside your assertion handler.</dd>
<dd>
"Handlers may be called inside high-priority interrupts!" This is problematic when relying on interrupts still working inside handlers for example for logging the failure via UART. Be aware of this and make sure you do not inadvertantly block inside handlers.</dd></dl>
<h2>Assertion Types</h2>
<p>The call site of the assertion decides whether an assertion can be recovered from or not. For example, if the CAN receive buffer has overflowed, but execution continues, then code to discard the message must be in place.</p>
<p>In case no handlers are registered or they all delegate the abandoment decision away, the call site must decide what the default behavior is. For this purpose the following assertions are available:</p>
<ol type="1">
<li><code>void <a class="el" href="group__modm__architecture__assert.html#ga13c92d3667401cbe959c82d9eea6ea9f">modm_assert()</a></code>: Always abandons execution when failed.</li>
<li><code>bool <a class="el" href="group__modm__architecture__assert.html#gadfb9269522e0d94f5aacb0ab903afeb0">modm_assert_continue_fail()</a></code>: Abandons execution unless overwritten.</li>
<li><code>bool <a class="el" href="group__modm__architecture__assert.html#ga0afeca111ac7a7edf74cae31a57b7591">modm_assert_continue_ignore()</a></code>: Resumes execution unless overwritten.</li>
</ol>
<p>Assertions that can resume execution return the evaluated boolean condition to be used to branch to cleanup code:</p>
<div class="fragment"><div class="line"><span class="comment">// Can be done inline in any flow control statement</span></div><div class="line"><span class="keywordflow">if</span> (not <a class="code" href="group__modm__architecture__assert.html#gadfb9269522e0d94f5aacb0ab903afeb0">modm_assert_continue_fail</a>(condition, ...)) {</div><div class="line">    <span class="comment">// cleanup code</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Or saved in a variable and queried multiple times.</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> cleanup = not <a class="code" href="group__modm__architecture__assert.html#ga0afeca111ac7a7edf74cae31a57b7591">modm_assert_continue_ignore</a>(condition, ...);</div><div class="line"><span class="keywordflow">if</span> (cleanup) {</div><div class="line">    <span class="comment">// cleanup code part 1</span></div><div class="line">}</div><div class="line"><span class="comment">// other code</span></div><div class="line"><span class="keywordflow">if</span> (cleanup) {</div><div class="line">    <span class="comment">// cleanup code part 1</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// or if cleanup is require *before* assertion is called</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> is_ok = (condition);</div><div class="line"><span class="keywordflow">if</span> (not is_ok) {</div><div class="line">    <span class="comment">// pre-assert cleanup</span></div><div class="line">}</div><div class="line"><a class="code" href="group__modm__architecture__assert.html#gadfb9269522e0d94f5aacb0ab903afeb0">modm_assert_continue_fail</a>(is_ok, ...);</div><div class="line"><span class="keywordflow">if</span> (not is_ok) {</div><div class="line">    <span class="comment">// post-assert cleanup</span></div><div class="line">}</div></div><!-- fragment --><p>Additionally, these assertions are only active in debug mode. Of course they still evaluate and return the condition in release mode, so you can use them just as above:</p>
<ol type="1">
<li><code>bool <a class="el" href="group__modm__architecture__assert.html#ga04ad3e2d57cd337bf25a1f0c8601d9b0">modm_assert_continue_fail_debug()</a></code></li>
<li><code>bool <a class="el" href="group__modm__architecture__assert.html#gafeddecc3fccc43849b042733cd4d42c6">modm_assert_continue_ignore_debug()</a></code></li>
</ol>
<h3>When to use what?</h3>
<p>Here are some guidelines for choosing the best assertion type:</p>
<ol type="1">
<li>Prefer to report errors via return types whenever possible!</li>
<li>If no sane recovery is possible, use <code><a class="el" href="group__modm__architecture__assert.html#ga13c92d3667401cbe959c82d9eea6ea9f">modm_assert()</a></code>.</li>
<li>If there is a (sensible) fallback for the failure, use <code>modm_assert_continue_{fail|ignore}()</code>: a. Abort by default, if the failure runs contrary to expected behavior. b. Resume by default, if the failure is expected and its behavior is well documented.</li>
<li>If the failure is expected <em>and</em> communicated via the normal API, or it only occurs rarely or through a clear misuse of the API, use <code>modm_assert_continue_{fail|ignore}_debug()</code>.</li>
</ol>
<p>Let's illustrate these with a few examples:</p>
<ol type="1">
<li>libc <code>exit()</code> is called. There is no sensible fallback, since there is no operating system to return control back to, so use <code><a class="el" href="group__modm__architecture__assert.html#ga13c92d3667401cbe959c82d9eea6ea9f">modm_assert()</a></code>.</li>
<li>An interrupt without a user-defined handler is triggered. The developer most likely enabled the wrong interrupt or provided the wrong handler. A sensible fallback is to disable the interrupt from triggering again and to alert the developer with <code>modm_assert_continue_fail(..., irq_number)</code>.</li>
<li>The CAN receive buffer overflows. A sensible fallback is to discard the message, which is documented as the expected behavior. Since this occurs asynchronously inside the CAN RX interrupt, there is no way to return an error code, so call <code>modm_assert_continue_ignore(..., &amp;message)</code> with a pointer to the message to inform the developer.</li>
<li>malloc fails to due to heap exhaustion and returns NULL, delegating the fallback implementation to the caller. Since the typical callers of malloc are known for not checking for NULL, using <code><a class="el" href="group__modm__architecture__assert.html#ga04ad3e2d57cd337bf25a1f0c8601d9b0">modm_assert_continue_fail_debug()</a></code> here is warranted, helping the developer find potential issues faster, and then ignoring this assert for debug builds by registering a handler via <code><a class="el" href="group__modm__architecture__assert.html#ga59f386a6fa7042bb1bcddbee5e9e7909">MODM_ASSERTION_HANDLER_DEBUG()</a></code>.</li>
<li>An I2C transfer failure is detected inside an interrupt. Such failures are expected on busses and typically the transfers are simply retried. You can use <code><a class="el" href="group__modm__architecture__assert.html#gafeddecc3fccc43849b042733cd4d42c6">modm_assert_continue_ignore_debug()</a></code> to give the developer a way to log the failure frequency without having to provide a special API. This can help diagnose a problem perhaps with the bus connection faster.</li>
</ol>
<h2>Abandoning execution</h2>
<p>If execution is abandoned <code>modm_abandon(const AssertionInfo &amp;info)</code> is called, which is a weak and empty function by default.</p>
<p>The function is meant to be overwritten by the application on embedded targets for example to disable relevant hardware for safety, log the failure via UART and perhaps blink some LEDs wildly to get the user's attention.</p>
<p>After returning from that function, the runtime resets the chip on Cortex-M, or loops forever on AVR, or calls <code>abort()</code> on hosted. You may of course, implement your own abandoning behavior instead of returning from <code><a class="el" href="group__modm__architecture__assert.html#gadef5785a7de8bb855ffde663d2e09e70">modm_abandon()</a></code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>"`modm_abandon()` may be called inside high-priority interrupts!" You can try to lower the active IRQ priority to let UART work, however, in the worst case you're called from within the HardFault or even NMI handlers which have the highest fixed priority.</dd></dl>
<h2>Module Options</h2>
<h3>modm:architecture:assert:with_description: Include assertion description</h3>
<p>Places the full description of a <code><a class="el" href="group__modm__architecture__assert.html#ga13c92d3667401cbe959c82d9eea6ea9f">modm_assert()</a></code> into the firmware image instead of only into the ELF file. This makes printing assertion information a simple standalone feature, fully independent of any additional script for decoding logging output, however, it may increase binary size considerably!</p>
<p>Generated with: <code>debug in [debug, off, release]</code> </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structmodm_1_1_assertion_info" id="structmodm_1_1_assertion_info"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structmodm_1_1_assertion_info">&#9670;&nbsp;</a></span>modm::AssertionInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct modm::AssertionInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Contains information about the failed assertion. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a2a277073453dbe8f37cfed3cd376940a"></a><a class="el" href="group__modm__architecture__assert.html#gaf2a1c6bb3af678b68ad976a75cb1208c">AbandonmentBehavior</a></td>
<td class="fieldname">
behavior</td>
<td class="fielddoc">
<a class="el" href="classmodm_1_1_can.html">Can</a> this assertion be ignored? </td></tr>
<tr><td class="fieldtype">
<a id="a01daacbe2550e26014ac5a5af7284637"></a>uintptr_t</td>
<td class="fieldname">
context</td>
<td class="fielddoc">
Optional context depends on assertion. </td></tr>
<tr><td class="fieldtype">
<a id="aafece82073e4365c082dd4d8c0fdf960"></a>const char *</td>
<td class="fieldname">
name</td>
<td class="fielddoc">
<a class="el" href="classmodm_1_1_can.html">Can</a> be used to recognise the assertion in code. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga16bc9b4ebefe47d1417ec75f99b30ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16bc9b4ebefe47d1417ec75f99b30ee6">&#9670;&nbsp;</a></span>MODM_ASSERTION_HANDLER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODM_ASSERTION_HANDLER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handler</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This adds a function to the list of assertion handlers to execute on assertion failure. Note that this macro does not give you any influence over the order of handler execution on assertion failure. Do not write assertion handlers that depend on any ordered execution!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>A function of signature <code>AssertionHandler</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59f386a6fa7042bb1bcddbee5e9e7909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59f386a6fa7042bb1bcddbee5e9e7909">&#9670;&nbsp;</a></span>MODM_ASSERTION_HANDLER_DEBUG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODM_ASSERTION_HANDLER_DEBUG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handler</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This adds an assertion handler only for debug mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>A function of signature <code>AssertionHandler</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59aff3dc76bdef1ddf77ab269520c6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59aff3dc76bdef1ddf77ab269520c6a5">&#9670;&nbsp;</a></span>MODM_ASSERTION_INFO_HAS_DESCRIPTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODM_ASSERTION_INFO_HAS_DESCRIPTION&#160;&#160;&#160;0/1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declares whether or not AssertionInfo has a <code>description</code> field. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaf2a1c6bb3af678b68ad976a75cb1208c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2a1c6bb3af678b68ad976a75cb1208c">&#9670;&nbsp;</a></span>AbandonmentBehavior</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__modm__architecture__assert.html#gaf2a1c6bb3af678b68ad976a75cb1208c">modm::AbandonmentBehavior</a> = typedef <a class="el" href="group__modm__architecture__register.html#gacdf81ef59f08411232bb3e7c8be57762">Flags8</a>&lt;<a class="el" href="group__modm__architecture__assert.html#gaf22c76f51642c50723ba439c5e080726">Abandonment</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga099140ec060a79b18029530dd05c2003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga099140ec060a79b18029530dd05c2003">&#9670;&nbsp;</a></span>AssertionHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__modm__architecture__assert.html#ga099140ec060a79b18029530dd05c2003">modm::AssertionHandler</a> = typedef <a class="el" href="group__modm__architecture__assert.html#gaf22c76f51642c50723ba439c5e080726">Abandonment</a> (*)(const <a class="el" href="group__modm__architecture__assert.html#structmodm_1_1_assertion_info">AssertionInfo</a> &amp;info)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signature of the assertion handlers </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaf22c76f51642c50723ba439c5e080726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf22c76f51642c50723ba439c5e080726">&#9670;&nbsp;</a></span>Abandonment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__modm__architecture__assert.html#gaf22c76f51642c50723ba439c5e080726">modm::Abandonment</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Describes abandonment type of assertions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf22c76f51642c50723ba439c5e080726a60a3629ef6a8f991f45d7a85f2458544"></a>DontCare&#160;</td><td class="fielddoc"><p>Do not care about failure. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf22c76f51642c50723ba439c5e080726afd038fc7f319e48f3115d92bf5bdbef9"></a>Ignore&#160;</td><td class="fielddoc"><p>Ignore this failure. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf22c76f51642c50723ba439c5e080726aceaa0734f0b3c738120c67344d8f3ec1"></a>Fail&#160;</td><td class="fielddoc"><p>This failure is reason for abandonment. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf22c76f51642c50723ba439c5e080726aa603905470e2a5b8c13e96b579ef0dba"></a>Debug&#160;</td><td class="fielddoc"><p>Only set for a debug-only failure. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gadef5785a7de8bb855ffde663d2e09e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadef5785a7de8bb855ffde663d2e09e70">&#9670;&nbsp;</a></span>modm_abandon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modm_abandon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__modm__architecture__assert.html#structmodm_1_1_assertion_info">modm::AssertionInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overwriteable abandonment handler for all targets.</p>
<p>You should overwrite this handler for custom failure behaviour like blinking LEDs and logging the failure via a serial connection. </p>

</div>
</div>
<a id="ga13c92d3667401cbe959c82d9eea6ea9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13c92d3667401cbe959c82d9eea6ea9f">&#9670;&nbsp;</a></span>modm_assert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">modm_noreturn void modm_assert </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>context</em> = <code>uintptr_t(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Always abandons execution</p>
<dl class="section note"><dt>Note</dt><dd>This assert is included in all builds! </dd></dl>

</div>
</div>
<a id="gadfb9269522e0d94f5aacb0ab903afeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfb9269522e0d94f5aacb0ab903afeb0">&#9670;&nbsp;</a></span>modm_assert_continue_fail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool modm_assert_continue_fail </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>context</em> = <code>uintptr_t(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abandons execution, unless overwritten by assertion handlers to resume.</p>
<dl class="section return"><dt>Returns</dt><dd>result of condition evaluation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This assert is included in all builds! </dd></dl>

</div>
</div>
<a id="ga04ad3e2d57cd337bf25a1f0c8601d9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04ad3e2d57cd337bf25a1f0c8601d9b0">&#9670;&nbsp;</a></span>modm_assert_continue_fail_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool modm_assert_continue_fail_debug </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>context</em> = <code>uintptr_t(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abandons execution, unless overwritten by assertion handlers to resume.</p>
<dl class="section note"><dt>Note</dt><dd>This assert is only included debug builds! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>result of condition evaluation </dd></dl>

</div>
</div>
<a id="ga0afeca111ac7a7edf74cae31a57b7591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0afeca111ac7a7edf74cae31a57b7591">&#9670;&nbsp;</a></span>modm_assert_continue_ignore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool modm_assert_continue_ignore </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>context</em> = <code>uintptr_t(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resumes execution, unless overwritten by assertion handlers to abandon.</p>
<dl class="section return"><dt>Returns</dt><dd>result of condition evaluation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This assert is included in all builds! </dd></dl>

</div>
</div>
<a id="gafeddecc3fccc43849b042733cd4d42c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafeddecc3fccc43849b042733cd4d42c6">&#9670;&nbsp;</a></span>modm_assert_continue_ignore_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool modm_assert_continue_ignore_debug </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>context</em> = <code>uintptr_t(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resumes execution, unless overwritten by assertion handlers to abandon.</p>
<dl class="section note"><dt>Note</dt><dd>This assert is only included debug builds! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>result of condition evaluation </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
