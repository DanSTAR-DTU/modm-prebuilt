<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>modm: ARM Cortex-M Core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">modm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">ARM Cortex-M Core<div class="ingroups"><a class="el" href="group__modm__platform.html">Platform HAL</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for ARM Cortex-M Core:</div>
<div class="dyncontent">
<div class="center"><img src="group__modm__platform__cortex__m.png" border="0" usemap="#group____modm____platform____cortex____m" alt=""/></div>
<map name="group____modm____platform____cortex____m" id="group____modm____platform____cortex____m">
<area shape="rect" href="group__modm__platform.html" title="lbuild module: modm:platform" alt="" coords="5,5,113,31"/>
<area shape="rect" title="lbuild module: modm:platform:cortex&#45;m" alt="" coords="161,5,312,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1platform_1_1_heap_table.html">modm::platform::HeapTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8db0a6548d7164c9124a8c5d74eaf474"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__platform__cortex__m.html#ga8db0a6548d7164c9124a8c5d74eaf474">MODM_HARDWARE_INIT</a>(function)</td></tr>
<tr class="separator:ga8db0a6548d7164c9124a8c5d74eaf474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59ce8a5b1d0b4b3ea222937c93a1caa5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__platform__cortex__m.html#ga59ce8a5b1d0b4b3ea222937c93a1caa5">MODM_HARDWARE_INIT_NAME</a>(name,  function)</td></tr>
<tr class="separator:ga59ce8a5b1d0b4b3ea222937c93a1caa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609c75050044610ef690ed86a16a92d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__platform__cortex__m.html#ga609c75050044610ef690ed86a16a92d4">MODM_HARDWARE_INIT_ORDER</a>(function,  order)</td></tr>
<tr class="separator:ga609c75050044610ef690ed86a16a92d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5168e2a05059dd5a06987dfb15401f3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__platform__cortex__m.html#ga5168e2a05059dd5a06987dfb15401f3b">MODM_HARDWARE_INIT_NAME_ORDER</a>(name,  function,  order)</td></tr>
<tr class="separator:ga5168e2a05059dd5a06987dfb15401f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>lbuild module: <code>modm:platform:cortex-m</code> </p>
<p>This module generates the startup code, vector table, linkerscript as well as initialize the heap, deal with assertions, provide blocking delay functions, atomic and unaligned access and the GNU build ID.</p>
<p>Since this is only initializes the generic ARM Cortex-M parts, it delegates device-specific initialization to the <code>modm:platform:core</code> module. Please depend on that module directly instead of this one.</p>
<h2><a class="anchor" id="autotoc_md76"></a>
Startup</h2>
<p>After reset, the ARM Cortex-M hardware jumps to the <code>Reset_Handler()</code>, which is implemented as follows:</p>
<ol type="1">
<li>The main stack pointer (MSP) is initialized by hardware.</li>
<li>Call <code>__modm_initialize_platform()</code> to initialize the device hardware.</li>
<li>Copy data from internal flash to internal RAM.</li>
<li>Zero sections in internal RAM.</li>
<li>Initialize ARM Cortex-M core: enable FPU and relocate vector table.</li>
<li>Execute shared hardware initialization functions.</li>
<li>Copy data from internal flash to <em>external</em> RAM.</li>
<li>Zero sections in <em>external</em> RAM.</li>
<li>Initialize heap via <code>__modm_initialize_memory()</code> (implemented by the <code>modm:platform:heap</code> module).</li>
<li>Call static constructors.</li>
<li>Call <code>main()</code> application entry point.</li>
<li>If <code>main()</code> returns, assert on <code>main.exit</code> (only in debug profile).</li>
<li>Reboot if assertion returns.</li>
</ol>
<h3><a class="anchor" id="autotoc_md77"></a>
Device Initialization</h3>
<p>The <code>__modm_initialize_platform()</code> function is called <em>directly</em> after reset, and its purpose is to initialize the device specific hardware, such as enable internal memories or disable the hardware watchdog timer.</p>
<p>It's important to understand that because the <code>.data</code> section has not yet been copied and the <code>.bss</code> section has not yet been zeroed, <b>there exists no valid C environment yet in this function context</b>! This means you cannot use any global variables, not even "local" static ones defined in your function, and depending on your hardware you may not even access read-only data (<code>const</code> variables, global OR local). In addition, if your linkerscript places the main stack pointer into a memory that is disabled on reset, you cannot even access the stack until you've enabled its backing memory. The <code>Reset_Handler</code> therefore calls this function in Assembly without accessing the stack.</p>
<p>It is strongly recommended to only read/write registers in this function, and perhaps even write this function in Assembly if deemed necessary. <em>Do not initialize the device clock, leave the default clock undisturbed</em>!</p>
<h3><a class="anchor" id="autotoc_md78"></a>
Additional Initialization</h3>
<p>A few modules need to initialize additional hardware during booting. For example: your device has external memories connected that you want to use for the heap. You can create a function that configures the peripherals for these external memories and place <em>a pointer to this function</em> into a special linker section and the startup script will then call this function before heap initialization.</p>
<p>Since the hardware init functions are called <em>after</em> internal data initialization, you have a valid C environment and thus can access the device normally, but since the calls happen <em>before</em> external data and heap initialization <b>you cannot use the heap in these functions</b>!</p>
<p>You can give a relative global order to your init functions. Ordered init functions are called first, then unordered init functions are called in any order. Please note that order numbers 0 - 999 are reserved for use by modm or other libraries!</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>"Unique init function names" Init function names need to be globally unique for linking. Unfortunately there is no simple way of stringifying C++ functions, so you have to provide a name manually for now.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> init_external_sdram()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// configure the hardware here</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// Startup script calls this function in any order, *after* prioritized functions!</span></div>
<div class="line"><a class="code" href="group__modm__platform__cortex__m.html#ga8db0a6548d7164c9124a8c5d74eaf474">MODM_HARDWARE_INIT</a>(init_external_sdram);</div>
<div class="line"><span class="comment">// If you need to pass a C++ function, you need to declare</span></div>
<div class="line"><a class="code" href="group__modm__platform__cortex__m.html#ga59ce8a5b1d0b4b3ea222937c93a1caa5">MODM_HARDWARE_INIT_NAME</a>(init_function_name, namespace::init_function);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If you need to initialize in a certain order use numbers &gt;= 1000</span></div>
<div class="line"><a class="code" href="group__modm__platform__cortex__m.html#ga609c75050044610ef690ed86a16a92d4">MODM_HARDWARE_INIT_ORDER</a>(init_before_sdram1, 1000);</div>
<div class="line"><span class="comment">// called after init_before_sdram1, since it has a higher order number</span></div>
<div class="line"><a class="code" href="group__modm__platform__cortex__m.html#ga5168e2a05059dd5a06987dfb15401f3b">MODM_HARDWARE_INIT_NAME_ORDER</a>(init_before_sdram2, namespace::function, 1001);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md79"></a>
Interrupt Vector Table</h2>
<p>The Cortex-M vector table (VTOR) is target-specific and generated using data from modm-devices. The main stack pointer is allocated according to the linkerscript and the <code>Reset_Handler</code> is defined by the startup script.</p>
<p>All handlers are weakly aliased to <code>Undefined_Handler</code>, which is called if an IRQ is enabled, but no handler is defined for it. This default handler determines the currectly active IRQ, sets its priority to the lowest level, and disables the IRQ from firing again and then asserts on <code>nvic.undef</code> with the (signed) IRQ number as context.</p>
<p>The lowering of the priority is necessary, since the assertion handlers (see <code>modm:architecture:assert</code>) are called from within this active IRQ and its priority should not prevent logging functionality (which might require a UART interrupt to flush data out) from working correctly.</p>
<h2><a class="anchor" id="autotoc_md80"></a>
Linkerscript</h2>
<p>This module provides building blocks for GNU ld linkerscripts in the form of Jinja macros that the <code>modm:platform:core</code> module <em>assembles</em> into a linkerscript, depending on the memory architecture of the target chosen.</p>
<p>The following macros are available:</p>
<ul>
<li><code>copyright()</code>: Copyright notice.</li>
<li><code>prefix()</code>: Contains <code>MEMORY</code> sections, output format and entry symbol and stack size definitions</li>
<li><code>section_vector_rom(memory)</code>: place the read-only vector table at the beginning of ROM <code>memory</code>.</li>
<li><code>section_vector_ram(memory)</code>: place the volatile vector table into RAM <code>memory</code>. You must satisfy alignment requirements externally.</li>
<li><code>section(memory, name)</code>: place section <code>.{name}</code> into <code>memory</code>.</li>
<li><code>section_stack(memory, start=None)</code>: place the main stack into <code>memory</code> after moving the location counter to <code>start</code>.</li>
<li><code>section_heap(memory, name, section=None)</code>: Fill up remaining space in <code>memory</code> with heap section <code>.{name}</code> and add to <code>section</code>.</li>
<li><code>section_rom(memory)</code>: place all read-only sections (<code>.text</code>, <code>.rodata</code> etc) into <code>memory</code>.</li>
<li><code>section_ram(memory, rom)</code>: place all volatile sections (<code>.data</code>, <code>.bss</code> etc)</li>
<li>into <code>memory</code> and load from <code>rom</code>.</li>
<li><code>section_table_zero(memory, sections=[])</code>: place the zeroing table (<code>.bss</code> plus <code>sections</code>) into <code>memory</code>.</li>
<li><code>section_table_copy(memory, sections=[])</code>: place the copying table (<code>.data</code>, <code>.fastdata</code>, <code>.vector_ram</code> plus <code>sections</code>) into <code>memory</code>.</li>
<li><code>section_table_extern(memory)</code>: place the zeroing and copying tables for external memories into <code>memory</code>.</li>
<li><code>section_table_heap(memory, sections)</code>: place heap tables containing <code>sections</code> into <code>memory</code>.</li>
<li><code>section_rom_start(memory)</code>: place at ROM start.</li>
<li><code>section_rom_end(memory)</code>: place at ROM end.</li>
<li><code>section_debug()</code>: place debug sections at the very end.</li>
</ul>
<p>Please consult the <code>modm:platform:core</code> documentation for the target-specific arrangement of these section macros and for potential limitations that the target's memory architecture poses.</p>
<h3><a class="anchor" id="autotoc_md81"></a>
Section &lt;tt&gt;.fastdata&lt;/tt&gt;</h3>
<p>For devices without data cache place the <code>.fastdata</code> section into the fastest RAM. Please note that the <code>.fastdata</code> section may need to be placed into RAM that is only accessable to the Cortex-M core, which can cause issues with DMA access. However, the <code>.fastdata</code> sections is not required to be DMA-able, and in such a case the developer needs to place the data into the generic <code>.data</code> section or choose a device with a DMA-able fast RAM.</p>
<h3><a class="anchor" id="autotoc_md82"></a>
Section &lt;tt&gt;.fastcode&lt;/tt&gt;</h3>
<p>For devices without an instruction cache or without a fast RAM connected to the I-bus, place <code>.fastcode</code> into ROM, which usually has a device-specific ROM cache. Please note that using a device with a dedicated instruction cache RAM yields much more predictable performance than executing from ROM, even with a ROM cache.</p>
<p>From the Cortex-M3 Technical Reference Manual:</p>
<blockquote class="doxtable">
<p>14.5 System Interface:</p>
<p>The system interface is a 32-bit AHB-Lite bus. Instruction and vector fetches, and data and debug accesses to the System memory space, 0x20000000 - 0xDFFFFFFF, 0xE0100000 - 0xFFFFFFFF, are performed over this bus.</p>
<p>14.5.6 Pipelined instruction fetches:</p>
<p>To provide a clean timing interface on the System bus, instruction and vector fetch requests to this bus are registered. This results in an additional cycle of latency because instructions fetched from the System bus take two cycles. This also means that back-to-back instruction fetches from the System bus are not possible.</p>
<p>Note: Instruction fetch requests to the ICode bus are not registered. Performance critical code must run from the ICode interface. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md83"></a>
Adding Sections</h3>
<p>The default linkerscripts only describe the internal memory, however, they can be extended for external memories using the <code>linkerscript.*</code> collectors of this module. For example, to add an external 16MB SDRAM to your device and place a static data section there that is copied from flash and use the remainder for heap access, these steps need to be performed:</p>
<p>Add the external SDRAM to the linkerscript's <code>MEMORY</code> statements in the <code>project.xml</code> configuration:</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">library</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">collectors</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">collect</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;modm:platform:cortex-m:linkerscript.memory&quot;</span>&gt;</div>
<div class="line">       <span class="keyword">SDRAM</span> (<span class="keyword">rwx</span>) : <span class="keyword">ORIGIN</span> = 0<span class="keyword">xC0000000</span>, <span class="keyword">LENGTH</span> = 16<span class="keyword">M</span></div>
<div class="line">    &lt;/<span class="keywordtype">collect</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">collectors</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">library</span>&gt;</div>
</div><!-- fragment --><p>You can also declare this as Python code in a lbuild <code>module.lb</code> file (useful for board support packages modules, see <code>modm:board</code>):</p>
<div class="fragment"><div class="line">env.collect(&quot;:platform:cortex-m:linkerscript.memory&quot;,</div>
<div class="line">            &quot;SDRAM (rwx) : ORIGIN = 0xC0000000, LENGTH = 16M&quot;)</div>
</div><!-- fragment --><p>Add a partition of the new memory to the linkerscripts <code>SECTION</code> statements. Since collectors order is only preserved locally, make sure to add the sections that depend on this order in <em>one value</em>. Here the previous value of the SDRAM location counter is required to "fill up" the remaining memory with the external heap section:</p>
<div class="fragment"><div class="line">linkerscript_sections = &quot;&quot;&quot;</div>
<div class="line">.sdramdata :</div>
<div class="line">{</div>
<div class="line">    __sdramdata_load = LOADADDR (.sdramdata);   /* address in FLASH */</div>
<div class="line">    __sdramdata_start = .;                      /* address in RAM */</div>
<div class="line"> </div>
<div class="line">    KEEP(*(.sdramdata))</div>
<div class="line"> </div>
<div class="line">    . = ALIGN(4);</div>
<div class="line">    __sdramdata_end = .;</div>
<div class="line">} &gt;SDRAM AT &gt;FLASH</div>
<div class="line"> </div>
<div class="line">.heap_extern (NOLOAD) : ALIGN(4)</div>
<div class="line">{</div>
<div class="line">    __heap_extern_start = .;</div>
<div class="line">    . = ORIGIN(SDRAM) + LENGTH(SDRAM);</div>
<div class="line">    __heap_extern_end = .;</div>
<div class="line">} &gt;SDRAM</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">env.collect(&quot;:platform:cortex-m:linkerscript.sections&quot;, linkerscript_sections)</div>
</div><!-- fragment --><p>Next, add the sections that need to be copied from ROM to RAM, here the contents of the <code>.sdramdata</code> section is stored in the internal <code>FLASH</code> memory and needs to be copied into SDRAM during the startup:</p>
<div class="fragment"><div class="line">linkerscript_copy = &quot;&quot;&quot;</div>
<div class="line">LONG(__sdramdata_load)</div>
<div class="line">LONG(__sdramdata_start)</div>
<div class="line">LONG(__sdramdata_end)</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">env.collect(&quot;:platform:cortex-m:linkerscript.table_extern.copy&quot;, linkerscript_copy)</div>
</div><!-- fragment --><p>And finally, to register the remaining memory in SDRAM with the allocator, add the memory range to the heap table. Remember to use the correct memory traits for this memory, see <code>modm:architecture:memory</code> for the trait definitions:</p>
<div class="fragment"><div class="line">linkerscript_heap = &quot;&quot;&quot;</div>
<div class="line">LONG(0x801f)</div>
<div class="line">LONG(__heap_extern_start)</div>
<div class="line">LONG(__heap_extern_end)</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">env.collect(&quot;:platform:cortex-m:linkerscript.table_extern.heap&quot;, linkerscript_heap)</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>"Linkerscript collectors are plain text" The collectors here only strip the leading/trailing whitespace and newlines and paste the result <em>as is</em> into the linkerscripts. No input validation is performed, so if you receive linker errors with your additions, please check the GNU LD documentation first.</dd></dl>
<h2><a class="anchor" id="autotoc_md84"></a>
Blocking Delay</h2>
<p>The delay functions as defined by <code>modm:architecture:delay</code> are implemented via software loop or hardware cycle counter (via DWT-&gt;CYCCNT, not available on ARMv6-M devices) and have the following limitations:</p>
<ul>
<li>nanosecond delay is implemented as a tight loop with better than 100ns resolution and accuracy at any CPU frequency.</li>
<li>microsecond delay has a maximum delay of 10 seconds.</li>
<li>millisecond delay is implemented via <code>modm::delay_us(ms * 1000)</code>, thus also has a maximum delay of 10 seconds.</li>
</ul>
<h2><a class="anchor" id="autotoc_md85"></a>
Compiler Options</h2>
<p>This module adds these architecture specific <a href="https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html">compiler options</a>:</p>
<ul>
<li><code>-mcpu=cortex-m{type}</code>: the target to compile for.</li>
<li><code>-mthumb</code>: only Thumb2 instruction set is supported.</li>
<li><code>-mfloat-abi=hard</code>: if FPU available use the fastest ABI available.</li>
<li><code>-mfpu=fpv{4, 5}-{sp}-d16</code>: single or double precision FPU.</li>
<li><code>-fsingle-precision-constant</code>: if SP-FPU, treat all FP constants as SP.</li>
<li><code>-Wdouble-promotion</code>: if SP-FPU, warn if FPs are promoted to doubles.</li>
</ul>
<p>In addition, these linker options are added:</p>
<ul>
<li><code>-nostartfiles</code>: modm implements its own startup script.</li>
<li><code>-wrap,_{calloc, malloc, realloc, free}_r</code>: reimplemented Newlib with our own allocator.</li>
</ul>
<h2><a class="anchor" id="autotoc_md86"></a>
Module Options</h2>
<h3><a class="anchor" id="autotoc_md87"></a>
modm:platform:cortex-m:main_stack_size: Minimum size of the application main stack</h3>
<p>The ARM Cortex-M uses a descending stack mechanism which is placed so that it grows towards the beginning of RAM. In case of a stack overflow the hardware then attempts to stack into invalid memory which triggers a HardFault. A stack overflow will therefore never overwrite any static or heap memory and this protection works without the MPU and therefore also on ARM Cortex-M0 devices.</p>
<p>If the vector table is relocated into RAM, the start address needs to be aligned to the next highest power-of-two word depending on the total number of device interrupts. On devices where the table is relocated into the same memory as the main stack, an alignment buffer up to 1kB is added to the main stack.</p>
<div class="fragment"><div class="line">|              ...                |</div>
<div class="line">|---------------------------------|</div>
<div class="line">|    Interrupt Vectors (in RAM)   |</div>
<div class="line">|        (<span class="keywordflow">if</span> re-mapped)           | &lt;-- vector table origin</div>
<div class="line">|---------------------------------| &lt;-- main stack top</div>
<div class="line">|           Main Stack            |</div>
<div class="line">|       (grows downwards)         |</div>
<div class="line">|               |                 |</div>
<div class="line">|               v                 |</div>
<div class="line">|---------------------------------|</div>
<div class="line">|  Alignment buffer <span class="keywordflow">for</span> vectors   |</div>
<div class="line">|   (overwritten by main stack!)  |</div>
<div class="line"><span class="stringliteral">&#39;---------------------------------&#39;</span> &lt;-- RAM origin</div>
</div><!-- fragment --><p>Generated with: <code>3*1024 (3072) in [256 .. 3*1024 .. 65536]</code> </p>
<h3><a class="anchor" id="autotoc_md88"></a>
modm:platform:cortex-m:vector_table_location: Vector table location in ROM or RAM</h3>
<p>The vector table is always stored in ROM and copied to RAM by the startup script if required. You can modify the RAM vector table using the CMSIS NVIC functions:</p>
<ul>
<li><code>void NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)</code></li>
<li><code>uint32_t NVIC_GetVector(IRQn_Type IRQn)</code></li>
</ul>
<p>For applications that do not modify the vector table at runtime, relocation to RAM is not necessary and can save a few hundred bytes of static memory.</p>
<p>By default, the fastest option is chosen depending on the target memory architecture. This does not always mean the table is copied into RAM, and therefore may not be modifiable with this option!</p>
<p>From the ARM Cortex-M4 Technical Reference Manual on exception handling:</p>
<blockquote class="doxtable">
<ul>
<li>Processor state is automatically stored to the stack on an exception, and automatically restored from the stack at the end of the Interrupt Service Routine.</li>
<li>The vector is fetched in parallel to the state saving, enabling efficient interrupt entry. </li>
</ul>
</blockquote>
<dl class="section warning"><dt>Warning</dt><dd>"On Interrupt Latency" Placing main stack and vector table into the same memory can significantly slow down interrupt latency, since both I-Code and D-Code memory interface need to fetch from the same access port.</dd></dl>
<p>Generated with: <code>ram in [ram, rom]</code> </p>
<h3><a class="anchor" id="autotoc_md89"></a>
modm:platform:cortex-m:linkerscript.flash_offset: Offset of FLASH Section Origin</h3>
<p>Add an offset to the default start address of the flash memory. This might be required for bootloaders located there.</p>
<dl class="section warning"><dt>Warning</dt><dd>"Vector Table Relocation" Not all offsets are compatible with the vector table relocation.</dd></dl>
<p>Generated with: <code>0 in [0 ... 0x80000]</code> </p>
<h3><a class="anchor" id="autotoc_md90"></a>
modm:platform:cortex-m:linkerscript.override: Path to project provided linkerscript</h3>
<p>Generated with: <code>[] in [Path]</code> </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga8db0a6548d7164c9124a8c5d74eaf474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8db0a6548d7164c9124a8c5d74eaf474">&#9670;&nbsp;</a></span>MODM_HARDWARE_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODM_HARDWARE_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">function</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call <code>function</code> during boot process. </p>

</div>
</div>
<a id="ga59ce8a5b1d0b4b3ea222937c93a1caa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59ce8a5b1d0b4b3ea222937c93a1caa5">&#9670;&nbsp;</a></span>MODM_HARDWARE_INIT_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODM_HARDWARE_INIT_NAME</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">function&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call <code>function</code> during boot process with a unique name. </p>

</div>
</div>
<a id="ga5168e2a05059dd5a06987dfb15401f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5168e2a05059dd5a06987dfb15401f3b">&#9670;&nbsp;</a></span>MODM_HARDWARE_INIT_NAME_ORDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODM_HARDWARE_INIT_NAME_ORDER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">function, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">order&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call <code>function</code> during boot process in a global order with a unique name. </p>

</div>
</div>
<a id="ga609c75050044610ef690ed86a16a92d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga609c75050044610ef690ed86a16a92d4">&#9670;&nbsp;</a></span>MODM_HARDWARE_INIT_ORDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODM_HARDWARE_INIT_ORDER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">function, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">order&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call <code>function</code> during boot process in a global order. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__modm__platform__cortex__m_html_ga5168e2a05059dd5a06987dfb15401f3b"><div class="ttname"><a href="group__modm__platform__cortex__m.html#ga5168e2a05059dd5a06987dfb15401f3b">MODM_HARDWARE_INIT_NAME_ORDER</a></div><div class="ttdeci">#define MODM_HARDWARE_INIT_NAME_ORDER(name, function, order)</div><div class="ttdef"><b>Definition:</b> hardware_init.hpp:38</div></div>
<div class="ttc" id="agroup__modm__platform__cortex__m_html_ga609c75050044610ef690ed86a16a92d4"><div class="ttname"><a href="group__modm__platform__cortex__m.html#ga609c75050044610ef690ed86a16a92d4">MODM_HARDWARE_INIT_ORDER</a></div><div class="ttdeci">#define MODM_HARDWARE_INIT_ORDER(function, order)</div><div class="ttdef"><b>Definition:</b> hardware_init.hpp:32</div></div>
<div class="ttc" id="agroup__modm__platform__cortex__m_html_ga59ce8a5b1d0b4b3ea222937c93a1caa5"><div class="ttname"><a href="group__modm__platform__cortex__m.html#ga59ce8a5b1d0b4b3ea222937c93a1caa5">MODM_HARDWARE_INIT_NAME</a></div><div class="ttdeci">#define MODM_HARDWARE_INIT_NAME(name, function)</div><div class="ttdef"><b>Definition:</b> hardware_init.hpp:26</div></div>
<div class="ttc" id="agroup__modm__platform__cortex__m_html_ga8db0a6548d7164c9124a8c5d74eaf474"><div class="ttname"><a href="group__modm__platform__cortex__m.html#ga8db0a6548d7164c9124a8c5d74eaf474">MODM_HARDWARE_INIT</a></div><div class="ttdeci">#define MODM_HARDWARE_INIT(function)</div><div class="ttdef"><b>Definition:</b> hardware_init.hpp:20</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
