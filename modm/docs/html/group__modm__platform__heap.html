<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>modm: Heap Memory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">modm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Heap Memory<div class="ingroups"><a class="el" href="group__modm__platform.html">Platform HAL</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Heap Memory:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__modm__platform__heap.png" border="0" alt="" usemap="#group____modm____platform____heap"/>
<map name="group____modm____platform____heap" id="group____modm____platform____heap">
<area shape="rect" id="node1" href="group__modm__platform.html" title="Platform HAL" alt="" coords="5,5,107,32"/>
</map>
</td></tr></table></center>
</div>
<p>lbuild module: <code>modm:platform:heap</code></p>
<p>Your applicaton is linked against the <code>newlib-nano</code> libc, which only requires the implementation of the <code>void* sbrk(ptrdiff_t size)</code> hook to use the heap.</p>
<p>However, the <code>sbrk</code> mechanism can only grow and shrink forward and backwards in memory and in particular it does not support discontinuous jumps from one memory section to another. The limitation stems from being designed for use with a MMU which would simply map another physical page into the linear virtual address space so that the heap section appears continuous to <code>sbrk</code>.</p>
<p>Since we do not have a MMU on Cortex-M, this strategy limits the use of the default newlib allocator to <em>one</em> continuous memory region. Therefore this module implements alternative allocators for devices with multiple memory regions with different traits and extends the C++ <code>operator new</code> to access them.</p>
<p>See the <code>modm:architecture:memory</code> module for what kind of memory traits exist.</p>
<h2>Heap is not Implemented Error</h2>
<p>This module is not included by default, and any attempt to use the heap fails with one or multiple linker error messages similiar to this:</p>
<div class="fragment"><div class="line">`_sbrk_r<span class="stringliteral">&#39; referenced in section `.text._malloc_r&#39;</span></div><div class="line">    of libc_nano.a(lib_a-nano-mallocr.o): defined in discarded section</div><div class="line">      `.Heap_is_not_implemented!_</div><div class="line">           _Please_include_the__modm:platform:heap__module_in_your_project!<span class="stringliteral">&#39;</span></div><div class="line"><span class="stringliteral">    of libmodm.a(no_heap.o)</span></div></div><!-- fragment --><p>This is to prevent you from <em>accidentally</em> using the heap, which may not be desirable for your application. If this occurs you have three choices. You can:</p>
<ol type="1">
<li>find and remove calls to malloc/new in your application, or</li>
<li>include this module with its predefined allocators, or</li>
<li>implement your own allocator.</li>
</ol>
<h2>Predefined Allocators</h2>
<p>There are several trade-offs to each allocator, however, as a rule of thumb, choose:</p>
<ul>
<li><code>newlib</code> for devices with one large continuous RAM region.</li>
<li><code>block</code> for devices with one very small RAM region.</li>
<li><code>tlsf</code> for devices with multiple, different discontinuous RAM regions.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>"Multi-SRAM regions" For devices which contain separate memories laid out in a continuous way (often called SRAM1, SRAM2, SRAM3, etc.) the <code>newlib</code> and <code>block</code> strategies choose the largest continuous memory region, <em>even though</em> unaligned accesses across memory regions may not be supported in hardware and lead to a bus fault! Consider using the TLSF implementation, which does not suffer from this issue.</dd>
<dd>
"Allocators are not interrupt- or thread-safe" No locking is implemented by default, if you need this feature, consider implementing your own custom allocator algorithm!</dd></dl>
<h3>Newlib</h3>
<p>The newlib-nano allocator is a simple linked list, its overhead is therefore low, but the access time may not be good. Due to the limitations of the <code>sbrk</code> mechanism only the largest memory region is used as heap! Depending on the device memory architecture this can leave large memory regions unused.</p>
<p>Consider using the TLSF allocator for devices with multiple discontinuous memories.</p>
<h3>Block</h3>
<p>For devices with very small memories, we recommend using the block allocator strategy, which uses a very light-weight and simple algorithm. This also only operates on one continuous memory region as heap.</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000003">Bug:</a></b></dt><dd>"The Block allocator does not implement realloc!" This is a bug in <code>modm:driver:block.allocator</code> and currently a <code>modm_assert</code> will fail.</dd></dl>
<h3>TLSF</h3>
<p>To use all non-statically allocated memory for heap, use the TLSF strategy, which natively supports multiple memory regions. This implementation treats all internal memories as separate regions, so unaligned access across memory boundaries is not an issue. To request heap memory of different traits, see the <code>modm:architecture:memory</code> module.</p>
<dl class="section note"><dt>Note</dt><dd>"TLSF has static overhead" The TLSF implementation has a static overhead of about 1kB per memory trait group, however, these can then contain multiple discontinuous regions. The upside of this large static allocation is very fast allocation times of O(1), but we recommend using TLSF only for devices with multiple large memory regions.</dd></dl>
<h2>Custom Allocator</h2>
<p>To implement your own allocator <b>do not</b> include this module. Instead initialize your heap in the function <code>__modm_initialize_memory()</code>, which gets called by the startup script after hardware init, but before static constructors are called (see <code>modm:platform:cortex-m</code> for details).</p>
<p>The simplest way to do so is to allocate a huge array into one of the heap sections and use this as your heap. Consult <code>modm:platform:core</code> for what heap sections your target provides!</p>
<div class="fragment"><div class="line"><a class="code" href="group__modm__architecture.html#ga1f31943d7806c1bd0a4ccb49399a4a81">modm_section</a>(<span class="stringliteral">&quot;.heap1&quot;</span>) <span class="comment">// always the main heap section</span></div><div class="line">uint8_t heap_begin[10*1024]; <span class="comment">// 10 kB heap</span></div><div class="line">const uint8_t *const heap_end{heap_begin + <span class="keyword">sizeof</span>(heap_begin)};</div><div class="line"></div><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> __modm_initialize_memory()</div><div class="line">{</div><div class="line">    <span class="comment">// Initialize your specific allocator algorithm here</span></div><div class="line">    allocator.initialize();</div><div class="line">}</div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>"Static constructors are only called afterwards!" Since constructors may call the heap, it must be initialized before static constructors are called. Only trivially constructed (POD) objects are already initialized!</dd></dl>
<h3>Using the HeapTable</h3>
<p>If you prefer a little more control, include the <code>modm:architecture:memory</code> module to get access to the internal <code><a class="el" href="classmodm_1_1platform_1_1_heap_table.html">modm::platform::HeapTable</a></code> API, which lists memory regions by traits and sizes.</p>
<p>For example to find the largest continuous memory section with default traits you can use this code:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> uint8_t *heap_begin{<span class="keyword">nullptr</span>};</div><div class="line"><span class="keyword">const</span> uint8_t *heap_end{<span class="keyword">nullptr</span>};</div><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> __modm_initialize_memory()</div><div class="line">{</div><div class="line">    <span class="keywordtype">bool</span> success = HeapTable::find_largest(&amp;heap_begin, &amp;heap_end,</div><div class="line">                                           <a class="code" href="group__modm__architecture__memory.html#ga08155d1288c3fd230809c6bffb2df227">modm::MemoryDefault</a>);</div><div class="line">    <a class="code" href="group__modm__architecture__assert.html#ga13c92d3667401cbe959c82d9eea6ea9f">modm_assert</a>(success, <span class="stringliteral">&quot;heap.init&quot;</span>, <span class="stringliteral">&quot;No default memory section found!&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>If you want to know more about the available memory regions, you can iterate over the heap table directly. This gives you full control over <em>where</em> you want to place you heap. You can print this table at runtime to get a feel for it:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> [traits, start, end, size] : <a class="code" href="classmodm_1_1platform_1_1_heap_table.html">modm::platform::HeapTable</a>())</div><div class="line">{</div><div class="line">    <a class="code" href="group__modm__debug.html#gaa818d31e0c2792328f81da25f256b79e">MODM_LOG_INFO</a>.printf(<span class="stringliteral">&quot;Memory section %#x @[0x%p,0x%p](%u)\n&quot;</span>,</div><div class="line">                         traits.value, start, end, size);</div><div class="line">}</div></div><!-- fragment --><h3>Providing sbrk</h3>
<p>To use the builtin allocator from newlib, all you need to provide is an implementation of the <code>sbrk</code> function. A simple implementation for a [<code>heap_begin</code>, <code>heap_end</code>] memory region looks like this:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> uint8_t *heap_top{heap_begin};</div><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span>* _sbrk_r(<span class="keyword">struct</span> _reent *,  ptrdiff_t size)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> uint8_t *<span class="keyword">const</span> heap = heap_top;</div><div class="line">    heap_top += size;</div><div class="line">    <a class="code" href="group__modm__architecture__assert.html#ga13c92d3667401cbe959c82d9eea6ea9f">modm_assert</a>(heap_top &lt; heap_end, <span class="stringliteral">&quot;heap.sbrk&quot;</span>, <span class="stringliteral">&quot;Heap overflowed!&quot;</span>);</div><div class="line">    <span class="keywordflow">return</span> (<span class="keywordtype">void</span>*) heap;</div><div class="line">}</div></div><!-- fragment --><h3>Wrapping malloc</h3>
<p>To use a completely custom allocator, you need to replace the newlib allocator by wrapping the <code>malloc</code>, <code>calloc</code>, <code>realloc</code> and <code>free</code> functions via the linker by adding this to your project configuration:</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">library</span>&gt;</div><div class="line">  </div><div class="line">  &lt;<span class="keywordtype">collectors</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">collect</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;:build:linkflags&quot;</span>&gt;-<span class="keyword">Wl</span>,-<span class="keyword">wrap</span>,<span class="keyword">_malloc_r</span>&lt;/<span class="keywordtype">collect</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">collect</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;:build:linkflags&quot;</span>&gt;-<span class="keyword">Wl</span>,-<span class="keyword">wrap</span>,<span class="keyword">_calloc_r</span>&lt;/<span class="keywordtype">collect</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">collect</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;:build:linkflags&quot;</span>&gt;-<span class="keyword">Wl</span>,-<span class="keyword">wrap</span>,<span class="keyword">_realloc_r</span>&lt;/<span class="keywordtype">collect</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">collect</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;:build:linkflags&quot;</span>&gt;-<span class="keyword">Wl</span>,-<span class="keyword">wrap</span>,<span class="keyword">_free_r</span>&lt;/<span class="keywordtype">collect</span>&gt;</div><div class="line">  &lt;/<span class="keywordtype">collectors</span>&gt;</div><div class="line">&lt;/<span class="keywordtype">library</span>&gt;</div></div><!-- fragment --><p>And then implement the following functions with your custom allocator:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *</div><div class="line">__wrap__malloc_r(<span class="keyword">struct</span> _reent *, <span class="keywordtype">size_t</span> size)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> allocator.malloc(size);</div><div class="line">}</div><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *</div><div class="line">__wrap__calloc_r(<span class="keyword">struct</span> _reent *, <span class="keywordtype">size_t</span> size)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> allocator.calloc(size);</div><div class="line">}</div><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *</div><div class="line">__wrap__realloc_r(<span class="keyword">struct</span> _reent *, <span class="keywordtype">void</span> *ptr, <span class="keywordtype">size_t</span> size)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> allocator.realloc(ptr, size);</div><div class="line">}</div><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> </div><div class="line">__wrap__free_r(<span class="keyword">struct</span> _reent *, <span class="keywordtype">void</span> *p)</div><div class="line">{</div><div class="line">    allocator.free(p);</div><div class="line">}</div></div><!-- fragment --><p>This is particularly recommended if you need a thread-safe malloc, which you implement here via the <code>_reent</code> struct. Consult newlib docs for details.</p>
<dl class="section note"><dt>Note</dt><dd>"sbrk is not called anymore" When wrapping these malloc functions, <code>_sbrk_r</code> is not called anymore, and therefore is thrown away by the linker, thus the linker error disappears. You therefore do not need to implement it, not even as a stub.</dd></dl>
<p>To also support memory traits, you need to overwrite the default implementation of <code>malloc_traits(size, traits)</code> which would otherwise just ignore the traits:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *</div><div class="line">malloc_traits(<span class="keywordtype">size_t</span> size, uint32_t ctraits)</div><div class="line">{</div><div class="line">    <span class="comment">// Convert back from C land to C++ land:</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structmodm_1_1_flags.html">modm::MemoryTraits</a> traits{ctraits};</div><div class="line">    <span class="keywordflow">if</span> (traits &amp; <a class="code" href="group__modm__architecture__memory.html#gga4ab452f5d1300a45f045af588fc25fb2a1416ef8ef2a4f38fdd03331f0698e60e">modm::MemoryTrait::AccessDMA</a>) {</div><div class="line">        <span class="comment">// check for space in DMA-able heap regions</span></div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="comment">// check other regions</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> ptr;</div><div class="line">}</div></div><!-- fragment --><h2>Module Options</h2>
<h3>modm:platform:heap:allocator: Heap allocator algorithms</h3>
<p>Generated with: <code>tlsf in [block, newlib, tlsf]</code> </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
