<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>modm: Resumable Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">modm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Resumable Functions<div class="ingroups"><a class="el" href="group__modm__processing.html">Processing</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_nested_resumable.html">modm::NestedResumable&lt; Levels &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmodm_1_1_resumable_result.html">modm::ResumableResult&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_resumable.html">modm::Resumable&lt; Functions &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8a210fcd55041e209c715e6c2d20046"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#gac8a210fcd55041e209c715e6c2d20046">RF_BEGIN</a>(index)</td></tr>
<tr class="separator:gac8a210fcd55041e209c715e6c2d20046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb13fb5ba3b91305efb86b131157b7e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#gadb13fb5ba3b91305efb86b131157b7e1">RF_BEGIN</a>()</td></tr>
<tr class="separator:gadb13fb5ba3b91305efb86b131157b7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadae4d1967a2940541461c43be4e32772"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#gadae4d1967a2940541461c43be4e32772">RF_END_RETURN</a>(result)</td></tr>
<tr class="separator:gadae4d1967a2940541461c43be4e32772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2052f0001fb0e336a076e5e2c9ef769e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga2052f0001fb0e336a076e5e2c9ef769e">RF_END</a>()</td></tr>
<tr class="separator:ga2052f0001fb0e336a076e5e2c9ef769e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f010ad2d7b0998799ecd86807c7a70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga83f010ad2d7b0998799ecd86807c7a70">RF_END_RETURN_CALL</a>(...)</td></tr>
<tr class="separator:ga83f010ad2d7b0998799ecd86807c7a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50fda47255530910b40d0e883b097f68"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga50fda47255530910b40d0e883b097f68">RF_YIELD</a>()</td></tr>
<tr class="separator:ga50fda47255530910b40d0e883b097f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac58b699432d4e11a92a7e10c5bb8b36d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#gac58b699432d4e11a92a7e10c5bb8b36d">RF_WAIT_THREAD</a>(child)</td></tr>
<tr class="separator:gac58b699432d4e11a92a7e10c5bb8b36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28077ce37251f81f1def791421af551d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga28077ce37251f81f1def791421af551d">RF_WAIT_WHILE</a>(condition)</td></tr>
<tr class="separator:ga28077ce37251f81f1def791421af551d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf68766e4a9dae0d7b42b0e82d3d3f7ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#gaf68766e4a9dae0d7b42b0e82d3d3f7ad">RF_WAIT_UNTIL</a>(condition)</td></tr>
<tr class="separator:gaf68766e4a9dae0d7b42b0e82d3d3f7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66ca200383c3e8f34f8ea4f596cd85c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga66ca200383c3e8f34f8ea4f596cd85c7">RF_CALL</a>(...)</td></tr>
<tr class="separator:ga66ca200383c3e8f34f8ea4f596cd85c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67e057d64cf6211e0449fc37c4deb5c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga67e057d64cf6211e0449fc37c4deb5c0">RF_CALL_BLOCKING</a>(...)</td></tr>
<tr class="separator:ga67e057d64cf6211e0449fc37c4deb5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga598af72b23d3556c1d276b6f52b4d900"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga598af72b23d3556c1d276b6f52b4d900">RF_RETURN_CALL</a>(...)</td></tr>
<tr class="separator:ga598af72b23d3556c1d276b6f52b4d900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51baeaa00320b4f640c229ff8dbf7ef8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga51baeaa00320b4f640c229ff8dbf7ef8">RF_RETURN</a>(result)</td></tr>
<tr class="separator:ga51baeaa00320b4f640c229ff8dbf7ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga068f9f637000e3da0f8d04d8b4e88f95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__processing__resumable.html#ga068f9f637000e3da0f8d04d8b4e88f95">RF_RETURN</a>()</td></tr>
<tr class="separator:ga068f9f637000e3da0f8d04d8b4e88f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>lbuild module: <code>modm:processing:resumable</code></p>
<p>An implementation of lightweight resumable functions which allow for nested calling.</p>
<p>This base class and its macros allows you to implement and use several resumable functions in one class. This allows you to modularize your code by placing it into its own resumable functions instead of the placing everything into one big method. It also allows you to call and run resumable functions within your resumables, so you can reuse their functionality.</p>
<p>Note that you should call resumable functions within a protothreads, with the <code>PT_CALL(group.resumable())</code> macro, which will return the result of the resumable function. To call a resumable function inside another resumable function, use the <code>RF_CALL(group.resumable())</code>.</p>
<p>You may use the <code>RF_CALL_BLOCKING(group.resumable())</code> macro to execute a resumable function outside of a protothread, however, this which will force the CPU to busy-wait until the resumable function ended.</p>
<dl class="section warning"><dt>Warning</dt><dd>"Resumable functions are not thread-safe!" Use an external mutex to arbitrate access if two Protothreads access the same resumable function.</dd></dl>
<p>You can either run your group of resumable functions independently from each other, or only run one function at a time, but it may nest calls to its own group's functions. So you need to inherit your group from <code><a class="el" href="classmodm_1_1_resumable.html">modm::Resumable</a>&lt;#Functions&gt;</code>, and from <code><a class="el" href="classmodm_1_1_nested_resumable.html">modm::NestedResumable</a>&lt;#Functions&gt;</code> respectively.</p>
<h2>Independent operation</h2>
<p>You must begin each resumable function using <code><a class="el" href="group__modm__processing__resumable.html#gadb13fb5ba3b91305efb86b131157b7e1">RF_BEGIN(index)</a></code> where <code>index</code> is the unique index of your resumable function starting at zero. You may exit and return a value by using <code><a class="el" href="group__modm__processing__resumable.html#ga068f9f637000e3da0f8d04d8b4e88f95">RF_RETURN(value)</a></code> or return the result of another resumable function using <code><a class="el" href="group__modm__processing__resumable.html#ga598af72b23d3556c1d276b6f52b4d900">RF_RETURN_CALL(resumable())</a></code>. This return value is wrapped in a <code><a class="el" href="structmodm_1_1_resumable_result.html">modm::ResumableResult</a>&lt;Type&gt;</code> struct and transparently returned by the <code>RF_CALL</code> macro so it can be used to influence your program flow. If the resumable function reaches <code><a class="el" href="group__modm__processing__resumable.html#ga2052f0001fb0e336a076e5e2c9ef769e">RF_END()</a></code> it will exit automatically, with the result of <code>0</code> cast to the return type. Should you wish to return a value at the end, you may use <code><a class="el" href="group__modm__processing__resumable.html#gadae4d1967a2940541461c43be4e32772">RF_END_RETURN(value)</a></code>. You may also return the result of another resumable function using <code><a class="el" href="group__modm__processing__resumable.html#ga83f010ad2d7b0998799ecd86807c7a70">RF_END_RETURN_CALL(resumable())</a></code>.</p>
<p>Be aware that this class keeps a separate state for each of your resumable functions. This allows each resumable function to be run at the same time. This might require the use of an internal semaphore or mutex if such dependencies exist in your use case. Take a look at the <code>NestedResumable</code> class for mutually exclusive resumable functions, which also require a little less memory.</p>
<h2>Nested operation</h2>
<p>You are responsible to choosing the right nesting depth! This class will guard itself against calling another resumable function at too deep a nesting level and fail the <code>resumable.begin.nesting</code> assertion! It is then up to you to recognize this in your program design and increase the nesting depth or rethink your code.</p>
<p>The resumable functions of this class are mutually exclusive, so only one resumable function of the same object can run at the same time. Even if you call another resumable function, it will simply return <code>modm::rf::WrongState</code>. Using the <code><a class="el" href="group__modm__processing__resumable.html#ga66ca200383c3e8f34f8ea4f596cd85c7">RF_CALL(resumable())</a></code> macro, you can wait for these resumable functions to become available and then run them, so you usually do not need to worry about those cases.</p>
<p>You must begin each resumable function using <code><a class="el" href="group__modm__processing__resumable.html#gac8a210fcd55041e209c715e6c2d20046">RF_BEGIN()</a></code>. You may exit and return a value by using <code><a class="el" href="group__modm__processing__resumable.html#ga068f9f637000e3da0f8d04d8b4e88f95">RF_RETURN(value)</a></code> or return the result of another resumable function using <code><a class="el" href="group__modm__processing__resumable.html#ga598af72b23d3556c1d276b6f52b4d900">RF_RETURN_CALL(resumable())</a></code>. This return value is wrapped in a <code><a class="el" href="structmodm_1_1_resumable_result.html">modm::ResumableResult</a>&lt;Type&gt;</code> struct and transparently returned by the <code>RF_CALL</code> macro so it can be used to influence your program flow. If the resumable function reaches <code><a class="el" href="group__modm__processing__resumable.html#ga2052f0001fb0e336a076e5e2c9ef769e">RF_END()</a></code> it will exit automatically, with the result of <code>0</code> cast to the return type. Should you wish to return a value at the end, you may use <code><a class="el" href="group__modm__processing__resumable.html#gadae4d1967a2940541461c43be4e32772">RF_END_RETURN(value)</a></code>. You may also return the result of another resumable function using <code><a class="el" href="group__modm__processing__resumable.html#ga83f010ad2d7b0998799ecd86807c7a70">RF_END_RETURN_CALL(resumable())</a></code>.</p>
<h2>Example</h2>
<p>Here is a (slightly over-engineered) example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;modm/platform/platform.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;modm/processing/processing.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Led = GpioOutputB0;</div><div class="line"></div><div class="line"><span class="keyword">class </span>BlinkingLight : <span class="keyword">public</span> <a class="code" href="classmodm_1_1pt_1_1_protothread.html">modm::pt::Protothread</a>, <span class="keyword">private</span> <a class="code" href="classmodm_1_1_nested_resumable.html">modm::NestedResumable</a>&lt;2&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">bool</span></div><div class="line">    run()</div><div class="line">    {</div><div class="line">        <a class="code" href="group__modm__processing__protothread.html#ga6da3471eb116970eb1dce79bfcc7cd3e">PT_BEGIN</a>();</div><div class="line"></div><div class="line">        <span class="comment">// set everything up</span></div><div class="line">        Led::setOutput();</div><div class="line">        Led::set();</div><div class="line"></div><div class="line">        <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">        {</div><div class="line">            Led::set();</div><div class="line">            <a class="code" href="group__modm__processing__protothread.html#gaeb2e9a2948001a68950eb6d8b26f0dbd">PT_CALL</a>(waitForTimer());</div><div class="line"></div><div class="line">            Led::reset();</div><div class="line">            <a class="code" href="group__modm__processing__protothread.html#gaeb2e9a2948001a68950eb6d8b26f0dbd">PT_CALL</a>(setTimer(200));</div><div class="line"></div><div class="line">            <a class="code" href="group__modm__processing__protothread.html#ga742a4c6aa99440473f54651233ebd28b">PT_WAIT_UNTIL</a>(timeout.isExpired());</div><div class="line">        }</div><div class="line"></div><div class="line">        <a class="code" href="group__modm__processing__protothread.html#ga146c4bb0e1f9f2020cd12b8dd7ff076e">PT_END</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="structmodm_1_1_resumable_result.html">modm::ResumableResult&lt;bool&gt;</a></div><div class="line">    waitForTimer()</div><div class="line">    {</div><div class="line">        <a class="code" href="group__modm__processing__resumable.html#gac8a210fcd55041e209c715e6c2d20046">RF_BEGIN</a>();</div><div class="line"></div><div class="line">        <span class="comment">// nested calling is allowed</span></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__modm__processing__resumable.html#ga66ca200383c3e8f34f8ea4f596cd85c7">RF_CALL</a>(setTimer(100)))</div><div class="line">        {</div><div class="line">            <a class="code" href="group__modm__processing__resumable.html#gaf68766e4a9dae0d7b42b0e82d3d3f7ad">RF_WAIT_UNTIL</a>(timeout.isExpired());</div><div class="line">            <a class="code" href="group__modm__processing__resumable.html#ga51baeaa00320b4f640c229ff8dbf7ef8">RF_RETURN</a>(<span class="keyword">true</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        <a class="code" href="group__modm__processing__resumable.html#gadae4d1967a2940541461c43be4e32772">RF_END_RETURN</a>(<span class="keyword">false</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="structmodm_1_1_resumable_result.html">modm::ResumableResult&lt;bool&gt;</a></div><div class="line">    setTimer(uint16_t new_timeout)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__modm__processing__resumable.html#gac8a210fcd55041e209c715e6c2d20046">RF_BEGIN</a>();</div><div class="line"></div><div class="line">        timeout.restart(std::chrono::milliseconds(new_timeout));</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>(timeout.isArmed()) {</div><div class="line">            <a class="code" href="group__modm__processing__resumable.html#ga51baeaa00320b4f640c229ff8dbf7ef8">RF_RETURN</a>(<span class="keyword">true</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// clean up code goes here</span></div><div class="line"></div><div class="line">        <a class="code" href="group__modm__processing__resumable.html#gadae4d1967a2940541461c43be4e32772">RF_END_RETURN</a>(<span class="keyword">false</span>);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <a class="code" href="classmodm_1_1_generic_timeout.html">modm::ShortTimeout</a> timeout;</div><div class="line">};</div><div class="line"></div><div class="line">BlinkingLight light;</div><div class="line"></div><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div><div class="line">    light.run();</div><div class="line">}</div></div><!-- fragment --><p>For other examples take a look in the <code>examples</code> folder in the modm root folder. The given example is in <code>modm/examples/generic/resumable</code>.</p>
<h2>Module Options</h2>
<h3>modm:processing:resumable:check_nesting_depth: Check nesting call depth</h3>
<p>Nested resumable functions protect against memory corruption by checking if the nesting level is within the allocated nesting level depth, on first entry to the function. If the allocated nesting level is exceeded, the assertion <code>resumable.begin.nesting</code> fails.</p>
<p>You may disable this behavior by disabling this check, then instead of the assertion, the function on entry returns the <code>modm::rf::NestingError</code> state value. <code><a class="el" href="group__modm__processing__protothread.html#gaeb2e9a2948001a68950eb6d8b26f0dbd">PT_CALL()</a></code> and <code><a class="el" href="group__modm__processing__resumable.html#ga66ca200383c3e8f34f8ea4f596cd85c7">RF_CALL()</a></code> macros will respond to this error by stopping function polling and just continuing program execution.</p>
<dl class="section note"><dt>Note</dt><dd>"Performance Penalty" This check is performed during the call to <code><a class="el" href="group__modm__processing__resumable.html#gadb13fb5ba3b91305efb86b131157b7e1">RF_BEGIN(N)</a></code>, so exactly once on function entry and not during every polling call, so the performance penalty is relatively small.</dd></dl>
<p>Generated with: <code>True in [True, False]</code> </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gac8a210fcd55041e209c715e6c2d20046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8a210fcd55041e209c715e6c2d20046">&#9670;&nbsp;</a></span>RF_BEGIN <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_BEGIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare start of resumable function with index. </p><dl class="section warning"><dt>Warning</dt><dd>Use at start of the <code>resumable()</code> implementation!</dd></dl>
<p>Declare start of a nested resumable function. This will immediately return if the nesting is too deep.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use at start of the <code>resumable()</code> implementation! </dd></dl>

</div>
</div>
<a id="gadb13fb5ba3b91305efb86b131157b7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb13fb5ba3b91305efb86b131157b7e1">&#9670;&nbsp;</a></span>RF_BEGIN <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_BEGIN</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare start of resumable function with index. </p><dl class="section warning"><dt>Warning</dt><dd>Use at start of the <code>resumable()</code> implementation!</dd></dl>
<p>Declare start of a nested resumable function. This will immediately return if the nesting is too deep.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use at start of the <code>resumable()</code> implementation! </dd></dl>

</div>
</div>
<a id="ga66ca200383c3e8f34f8ea4f596cd85c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66ca200383c3e8f34f8ea4f596cd85c7">&#9670;&nbsp;</a></span>RF_CALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_CALL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls a resumable function and returns its result. </p>

</div>
</div>
<a id="ga67e057d64cf6211e0449fc37c4deb5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67e057d64cf6211e0449fc37c4deb5c0">&#9670;&nbsp;</a></span>RF_CALL_BLOCKING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_CALL_BLOCKING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls a resumable function, busy-waits and returns its result.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use this with extreme caution, this can cause deadlocks! </dd></dl>

</div>
</div>
<a id="ga2052f0001fb0e336a076e5e2c9ef769e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2052f0001fb0e336a076e5e2c9ef769e">&#9670;&nbsp;</a></span>RF_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_END</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End the resumable function. You can use this to return <code>void</code>, or if the result does not matter.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use at end of the <code>resumable()</code> implementation only! </dd></dl>

</div>
</div>
<a id="gadae4d1967a2940541461c43be4e32772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadae4d1967a2940541461c43be4e32772">&#9670;&nbsp;</a></span>RF_END_RETURN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_END_RETURN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">result</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End the resumable function and return a result.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use at end of the <code>resumable()</code> implementation only! </dd></dl>

</div>
</div>
<a id="ga83f010ad2d7b0998799ecd86807c7a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83f010ad2d7b0998799ecd86807c7a70">&#9670;&nbsp;</a></span>RF_END_RETURN_CALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_END_RETURN_CALL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End the resumable function by calling another resumable function and returning its result.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use at end of the <code>resumable()</code> implementation only! </dd></dl>

</div>
</div>
<a id="ga51baeaa00320b4f640c229ff8dbf7ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51baeaa00320b4f640c229ff8dbf7ef8">&#9670;&nbsp;</a></span>RF_RETURN <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_RETURN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">result</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop and exit from resumable function with a result.</p>
<p>Stop and exit from resumable function of <code>void</code> return type. </p>

</div>
</div>
<a id="ga068f9f637000e3da0f8d04d8b4e88f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga068f9f637000e3da0f8d04d8b4e88f95">&#9670;&nbsp;</a></span>RF_RETURN <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_RETURN</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop and exit from resumable function with a result.</p>
<p>Stop and exit from resumable function of <code>void</code> return type. </p>

</div>
</div>
<a id="ga598af72b23d3556c1d276b6f52b4d900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga598af72b23d3556c1d276b6f52b4d900">&#9670;&nbsp;</a></span>RF_RETURN_CALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_RETURN_CALL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exits a resumable function and returns another resumable function's result. </p>

</div>
</div>
<a id="gac58b699432d4e11a92a7e10c5bb8b36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac58b699432d4e11a92a7e10c5bb8b36d">&#9670;&nbsp;</a></span>RF_WAIT_THREAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_WAIT_THREAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">child</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cause resumable function to wait until given child protothread completes. </p>

</div>
</div>
<a id="gaf68766e4a9dae0d7b42b0e82d3d3f7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf68766e4a9dae0d7b42b0e82d3d3f7ad">&#9670;&nbsp;</a></span>RF_WAIT_UNTIL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_WAIT_UNTIL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">condition</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cause resumable function to wait <b>until</b> given <code>condition</code> is true. </p>

</div>
</div>
<a id="ga28077ce37251f81f1def791421af551d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28077ce37251f81f1def791421af551d">&#9670;&nbsp;</a></span>RF_WAIT_WHILE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_WAIT_WHILE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">condition</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cause resumable function to wait <b>while</b> given <code>condition</code> is true. </p>

</div>
</div>
<a id="ga50fda47255530910b40d0e883b097f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50fda47255530910b40d0e883b097f68">&#9670;&nbsp;</a></span>RF_YIELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RF_YIELD</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yield resumable function until next invocation. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
