<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>modm: modm::BoundedDeque&lt; T, N &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">modm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemodm.html">modm</a></li><li class="navelem"><a class="el" href="classmodm_1_1_bounded_deque.html">BoundedDeque</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmodm_1_1_bounded_deque-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">modm::BoundedDeque&lt; T, N &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__modm__container.html">Containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="deque_8hpp_source.html">modm/container/deque.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab9c0649c8f547e1e364c99f09dddc77c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#ab9c0649c8f547e1e364c99f09dddc77c">Index</a> = std::conditional_t&lt;(N &gt;=255), uint_fast16_t, uint_fast8_t &gt;</td></tr>
<tr class="separator:ab9c0649c8f547e1e364c99f09dddc77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6c75d57dfc1ac40f10fb6bb79d951b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#aef6c75d57dfc1ac40f10fb6bb79d951b">Size</a> = <a class="el" href="classmodm_1_1_bounded_deque.html#ab9c0649c8f547e1e364c99f09dddc77c">Index</a></td></tr>
<tr class="separator:aef6c75d57dfc1ac40f10fb6bb79d951b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3e12ae31276790c19d4568afabc79dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#ac3e12ae31276790c19d4568afabc79dc">BoundedDeque</a> ()</td></tr>
<tr class="separator:ac3e12ae31276790c19d4568afabc79dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2935e9f8aa608fdc5581589c302f45e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a2935e9f8aa608fdc5581589c302f45e3">isEmpty</a> () const</td></tr>
<tr class="separator:a2935e9f8aa608fdc5581589c302f45e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd325f252cfa71f81db19a28423a172"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#aabd325f252cfa71f81db19a28423a172">isNotEmpty</a> () const</td></tr>
<tr class="separator:aabd325f252cfa71f81db19a28423a172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf95372cd4d6808122ef7b5958dd406c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#acf95372cd4d6808122ef7b5958dd406c">isFull</a> () const</td></tr>
<tr class="separator:acf95372cd4d6808122ef7b5958dd406c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a0719915d1a084d3fdf1e4946ce93f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a16a0719915d1a084d3fdf1e4946ce93f">isNotFull</a> () const</td></tr>
<tr class="separator:a16a0719915d1a084d3fdf1e4946ce93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2b7a4255e5ef6b30735b6eeddbd398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmodm_1_1_bounded_deque.html#aef6c75d57dfc1ac40f10fb6bb79d951b">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#adb2b7a4255e5ef6b30735b6eeddbd398">getSize</a> () const</td></tr>
<tr class="separator:adb2b7a4255e5ef6b30735b6eeddbd398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79880017b432aa7a6b63d1f723b678af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmodm_1_1_bounded_deque.html#aef6c75d57dfc1ac40f10fb6bb79d951b">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a79880017b432aa7a6b63d1f723b678af">getMaxSize</a> () const</td></tr>
<tr class="separator:a79880017b432aa7a6b63d1f723b678af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645eb1989c7a847c6655f0a6c8df7832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a645eb1989c7a847c6655f0a6c8df7832">clear</a> ()</td></tr>
<tr class="separator:a645eb1989c7a847c6655f0a6c8df7832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da219911bf80d9e61d40252596d0e79"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a5da219911bf80d9e61d40252596d0e79">getFront</a> ()</td></tr>
<tr class="separator:a5da219911bf80d9e61d40252596d0e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1631cd7aa52c1de4bb5eb9c86acf82b2"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a1631cd7aa52c1de4bb5eb9c86acf82b2">getFront</a> () const</td></tr>
<tr class="separator:a1631cd7aa52c1de4bb5eb9c86acf82b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7ed6b10bff5024a0eb5d98e5673ca7"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a4c7ed6b10bff5024a0eb5d98e5673ca7">get</a> (<a class="el" href="classmodm_1_1_bounded_deque.html#ab9c0649c8f547e1e364c99f09dddc77c">Index</a> n)</td></tr>
<tr class="separator:a4c7ed6b10bff5024a0eb5d98e5673ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45173c5f0fe2360286ed6b0008aa8eb"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#ae45173c5f0fe2360286ed6b0008aa8eb">get</a> (<a class="el" href="classmodm_1_1_bounded_deque.html#ab9c0649c8f547e1e364c99f09dddc77c">Index</a> n) const</td></tr>
<tr class="separator:ae45173c5f0fe2360286ed6b0008aa8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e416acbbc875a8ef94679caee19589"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a49e416acbbc875a8ef94679caee19589">operator[]</a> (<a class="el" href="classmodm_1_1_bounded_deque.html#ab9c0649c8f547e1e364c99f09dddc77c">Index</a> n)</td></tr>
<tr class="separator:a49e416acbbc875a8ef94679caee19589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf149080d7900386ed2bbac90f076b2"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a9bf149080d7900386ed2bbac90f076b2">operator[]</a> (<a class="el" href="classmodm_1_1_bounded_deque.html#ab9c0649c8f547e1e364c99f09dddc77c">Index</a> n) const</td></tr>
<tr class="separator:a9bf149080d7900386ed2bbac90f076b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d64f1ff0f2f7ba59ef16e5f7a2d8a63"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a8d64f1ff0f2f7ba59ef16e5f7a2d8a63">rget</a> (<a class="el" href="classmodm_1_1_bounded_deque.html#ab9c0649c8f547e1e364c99f09dddc77c">Index</a> n)</td></tr>
<tr class="separator:a8d64f1ff0f2f7ba59ef16e5f7a2d8a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffbae27159c87e077e245a72a6b3f08"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#aaffbae27159c87e077e245a72a6b3f08">rget</a> (<a class="el" href="classmodm_1_1_bounded_deque.html#ab9c0649c8f547e1e364c99f09dddc77c">Index</a> n) const</td></tr>
<tr class="separator:aaffbae27159c87e077e245a72a6b3f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0986d7ea4ff7c83f953f81399160573f"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a0986d7ea4ff7c83f953f81399160573f">getBack</a> ()</td></tr>
<tr class="separator:a0986d7ea4ff7c83f953f81399160573f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9152c24d926d4745c45eec56f9e45945"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a9152c24d926d4745c45eec56f9e45945">getBack</a> () const</td></tr>
<tr class="separator:a9152c24d926d4745c45eec56f9e45945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6546a780a369e92f5af4df88c80e093b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a6546a780a369e92f5af4df88c80e093b">append</a> (const T &amp;value)</td></tr>
<tr class="separator:a6546a780a369e92f5af4df88c80e093b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfe60e646a8e19663849496e68a801f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#afbfe60e646a8e19663849496e68a801f">appendOverwrite</a> (const T &amp;value)</td></tr>
<tr class="separator:afbfe60e646a8e19663849496e68a801f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ee74c264d6a90cb16f96e4b2fc2eea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a21ee74c264d6a90cb16f96e4b2fc2eea">prepend</a> (const T &amp;value)</td></tr>
<tr class="separator:a21ee74c264d6a90cb16f96e4b2fc2eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40d3af1ae7042315b936ecb9ab37188"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#ad40d3af1ae7042315b936ecb9ab37188">prependOverwrite</a> (const T &amp;value)</td></tr>
<tr class="separator:ad40d3af1ae7042315b936ecb9ab37188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591f9a8471088efebc851bbeb87f590a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a591f9a8471088efebc851bbeb87f590a">removeBack</a> ()</td></tr>
<tr class="separator:a591f9a8471088efebc851bbeb87f590a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6bb9dcb60b2f591d6ed3bc9cfe99c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a3c6bb9dcb60b2f591d6ed3bc9cfe99c8">removeFront</a> ()</td></tr>
<tr class="separator:a3c6bb9dcb60b2f591d6ed3bc9cfe99c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21520b5bd74788ddc0b139888d203224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmodm_1_1_bounded_deque_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#a21520b5bd74788ddc0b139888d203224">begin</a> () const</td></tr>
<tr class="separator:a21520b5bd74788ddc0b139888d203224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde1dae27e68305a00fdbdec74ae2c5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmodm_1_1_bounded_deque_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#afde1dae27e68305a00fdbdec74ae2c5c">end</a> () const</td></tr>
<tr class="separator:afde1dae27e68305a00fdbdec74ae2c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac220ce1c155db1ac44146c12d178056f"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1_bounded_deque.html#ac220ce1c155db1ac44146c12d178056f">const_iterator</a></td></tr>
<tr class="separator:ac220ce1c155db1ac44146c12d178056f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, std::size_t N&gt;<br />
class modm::BoundedDeque&lt; T, N &gt;</h3>

<p>Double ended queue. </p>
<p>Internally organized as a ring buffer.</p>
<pre class="fragment">*           tail --\                 /-- head
*                  |                 |
*        +------+------+---- ----+------+------+
*      0 |      | data |   ...   | data |      | N-1
*        +------+------+---- ----+------+------+
*           |      |                 |      |
* prepend --/      |                 |      \-- append
*                  |                 |
*       getFront --/                 \-- getBack
* </pre><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the elements </td></tr>
    <tr><td class="paramname">N</td><td>Size of the queue</td></tr>
  </table>
  </dd>
</dl>
<p>Up to a size of 254 small index variables with 8-bits are used, after this they are switched to 16-bit.</p>
<dl class="section warning"><dt>Warning</dt><dd>This class don't check if the container is empty before a pop-operation. You have to do this by yourself!</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Fabian Greif </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab9c0649c8f547e1e364c99f09dddc77c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c0649c8f547e1e364c99f09dddc77c">&#9670;&nbsp;</a></span>Index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::<a class="el" href="classmodm_1_1_bounded_deque.html#ab9c0649c8f547e1e364c99f09dddc77c">Index</a> =  std::conditional_t&lt; (N &gt;= 255), uint_fast16_t, uint_fast8_t &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef6c75d57dfc1ac40f10fb6bb79d951b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6c75d57dfc1ac40f10fb6bb79d951b">&#9670;&nbsp;</a></span>Size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::<a class="el" href="classmodm_1_1_bounded_deque.html#aef6c75d57dfc1ac40f10fb6bb79d951b">Size</a> =  <a class="el" href="classmodm_1_1_bounded_deque.html#ab9c0649c8f547e1e364c99f09dddc77c">Index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac3e12ae31276790c19d4568afabc79dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e12ae31276790c19d4568afabc79dc">&#9670;&nbsp;</a></span>BoundedDeque()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::<a class="el" href="classmodm_1_1_bounded_deque.html">BoundedDeque</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6546a780a369e92f5af4df88c80e093b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6546a780a369e92f5af4df88c80e093b">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbfe60e646a8e19663849496e68a801f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfe60e646a8e19663849496e68a801f">&#9670;&nbsp;</a></span>appendOverwrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::appendOverwrite </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an item to the back of the deque overwriting existing items. </p>
<p>This method, in contrast to <code><a class="el" href="classmodm_1_1_bounded_deque.html#a6546a780a369e92f5af4df88c80e093b">append()</a></code>, overwrites existing items in the deque if it is full. When an item is appended to the already full deque, the front item is removed to use its space for the new item, which is inserted after back. </p>

</div>
</div>
<a id="a21520b5bd74788ddc0b139888d203224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21520b5bd74788ddc0b139888d203224">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmodm_1_1_bounded_deque_1_1const__iterator.html">const_iterator</a> <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a645eb1989c7a847c6655f0a6c8df7832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645eb1989c7a847c6655f0a6c8df7832">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the container. </p>
<dl class="section warning"><dt>Warning</dt><dd>This will discard all the items in the container </dd></dl>

</div>
</div>
<a id="afde1dae27e68305a00fdbdec74ae2c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde1dae27e68305a00fdbdec74ae2c5c">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmodm_1_1_bounded_deque_1_1const__iterator.html">const_iterator</a> <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c7ed6b10bff5024a0eb5d98e5673ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7ed6b10bff5024a0eb5d98e5673ca7">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmodm_1_1_bounded_deque.html#ab9c0649c8f547e1e364c99f09dddc77c">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get item at specified index. </p>
<p>Returns a reference to the item at index <code>n</code>, counting 0-indexed from Front to Back, which is the same order in that the items were appended and the iterator addresses them.</p>
<dl class="section warning"><dt>Warning</dt><dd>Please make sure <code>n</code> is a valid index: 0 &lt;= <em>n</em> &lt; <em>size</em>. Other indexes will cause undefined behaviour. </dd></dl>

</div>
</div>
<a id="ae45173c5f0fe2360286ed6b0008aa8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45173c5f0fe2360286ed6b0008aa8eb">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmodm_1_1_bounded_deque.html#ab9c0649c8f547e1e364c99f09dddc77c">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0986d7ea4ff7c83f953f81399160573f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0986d7ea4ff7c83f953f81399160573f">&#9670;&nbsp;</a></span>getBack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::getBack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9152c24d926d4745c45eec56f9e45945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9152c24d926d4745c45eec56f9e45945">&#9670;&nbsp;</a></span>getBack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::getBack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5da219911bf80d9e61d40252596d0e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da219911bf80d9e61d40252596d0e79">&#9670;&nbsp;</a></span>getFront() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::getFront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1631cd7aa52c1de4bb5eb9c86acf82b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1631cd7aa52c1de4bb5eb9c86acf82b2">&#9670;&nbsp;</a></span>getFront() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::getFront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79880017b432aa7a6b63d1f723b678af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79880017b432aa7a6b63d1f723b678af">&#9670;&nbsp;</a></span>getMaxSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmodm_1_1_bounded_deque.html#aef6c75d57dfc1ac40f10fb6bb79d951b">Size</a> <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::getMaxSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb2b7a4255e5ef6b30735b6eeddbd398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2b7a4255e5ef6b30735b6eeddbd398">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmodm_1_1_bounded_deque.html#aef6c75d57dfc1ac40f10fb6bb79d951b">Size</a> <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2935e9f8aa608fdc5581589c302f45e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2935e9f8aa608fdc5581589c302f45e3">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acf95372cd4d6808122ef7b5958dd406c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf95372cd4d6808122ef7b5958dd406c">&#9670;&nbsp;</a></span>isFull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::isFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aabd325f252cfa71f81db19a28423a172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd325f252cfa71f81db19a28423a172">&#9670;&nbsp;</a></span>isNotEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::isNotEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a16a0719915d1a084d3fdf1e4946ce93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a0719915d1a084d3fdf1e4946ce93f">&#9670;&nbsp;</a></span>isNotFull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::isNotFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49e416acbbc875a8ef94679caee19589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e416acbbc875a8ef94679caee19589">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmodm_1_1_bounded_deque.html#ab9c0649c8f547e1e364c99f09dddc77c">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get item at specified index. </p>
<p>Returns a reference to the item at index <code>n</code>, counting 0-indexed from Front to Back.</p>
<dl class="section warning"><dt>Warning</dt><dd>Please make sure <code>n</code> is a valid index: 0 &lt;= <em>n</em> &lt; <em>size</em>. Other indexes will cause undefined behaviour. </dd></dl>

</div>
</div>
<a id="a9bf149080d7900386ed2bbac90f076b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf149080d7900386ed2bbac90f076b2">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmodm_1_1_bounded_deque.html#ab9c0649c8f547e1e364c99f09dddc77c">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21ee74c264d6a90cb16f96e4b2fc2eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ee74c264d6a90cb16f96e4b2fc2eea">&#9670;&nbsp;</a></span>prepend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad40d3af1ae7042315b936ecb9ab37188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40d3af1ae7042315b936ecb9ab37188">&#9670;&nbsp;</a></span>prependOverwrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::prependOverwrite </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepend an item to the front of the deque overwriting existing items. </p>
<p>This method, in contrast to <code><a class="el" href="classmodm_1_1_bounded_deque.html#a21ee74c264d6a90cb16f96e4b2fc2eea">prepend()</a></code>, overwrites existing items in the deque if it is full. When an item is prepended to the already full deque, the back item is removed to use its space for the new item, which is inserted at front. </p>

</div>
</div>
<a id="a591f9a8471088efebc851bbeb87f590a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591f9a8471088efebc851bbeb87f590a">&#9670;&nbsp;</a></span>removeBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::removeBack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c6bb9dcb60b2f591d6ed3bc9cfe99c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6bb9dcb60b2f591d6ed3bc9cfe99c8">&#9670;&nbsp;</a></span>removeFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::removeFront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d64f1ff0f2f7ba59ef16e5f7a2d8a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d64f1ff0f2f7ba59ef16e5f7a2d8a63">&#9670;&nbsp;</a></span>rget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::rget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmodm_1_1_bounded_deque.html#ab9c0649c8f547e1e364c99f09dddc77c">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get item at specified index. </p>
<p>Returns a reference to the item at index <code>n</code>. The items are indexed in reverse (Back to Front), which is their order when they have been prepended.</p>
<dl class="section warning"><dt>Warning</dt><dd>Please make sure <code>n</code> is a valid index: 0 &lt;= <em>n</em> &lt; <em>size</em>. Other indexes will cause undefined behaviour. </dd></dl>

</div>
</div>
<a id="aaffbae27159c87e077e245a72a6b3f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaffbae27159c87e077e245a72a6b3f08">&#9670;&nbsp;</a></span>rget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classmodm_1_1_bounded_deque.html">modm::BoundedDeque</a>&lt; T, N &gt;::rget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmodm_1_1_bounded_deque.html#ab9c0649c8f547e1e364c99f09dddc77c">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac220ce1c155db1ac44146c12d178056f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac220ce1c155db1ac44146c12d178056f">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classmodm_1_1_bounded_deque_1_1const__iterator.html">const_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
