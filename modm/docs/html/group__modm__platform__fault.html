<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>modm: ARM Cortex-M Fault Reporters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">modm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ARM Cortex-M Fault Reporters<div class="ingroups"><a class="el" href="group__modm__platform.html">Platform HAL</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for ARM Cortex-M Fault Reporters:</div>
<div class="dyncontent">
<div class="center"><img src="group__modm__platform__fault.png" border="0" usemap="#group____modm____platform____fault" alt=""/></div>
<map name="group____modm____platform____fault" id="group____modm____platform____fault">
<area shape="rect" href="group__modm__platform.html" title="lbuild module: modm:platform" alt="" coords="5,13,113,38"/>
<area shape="rect" title="lbuild module: modm:platform:fault" alt="" coords="161,5,313,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodm_1_1platform_1_1_fault_reporter.html">modm::platform::FaultReporter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafc7f29452fcc4cd9caf7254c27b10146"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modm__platform__fault.html#gafc7f29452fcc4cd9caf7254c27b10146">modm_hardfault_entry</a> ()</td></tr>
<tr class="separator:gafc7f29452fcc4cd9caf7254c27b10146"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>lbuild module: <code>modm:platform:fault</code> </p>
<p>This module manages data storage for core dumps provided by the <code>:crashcatcher</code> module to investigate HardFault events via offline post-mortem debugging. The data is stored in the volatile memory designated for the heap.</p>
<p>This works as follows:</p>
<ol type="1">
<li>A HardFault occurs and is intercepted by CrashCatcher.</li>
<li>CrashCatcher calls into this module to store the core dump in the heap as defined by the linkerscript's <code>.table.heap</code> section, thus effectively overwriting the heap, then reboots the device.</li>
<li>On reboot, only the remaining heap memory is initialized, leaving the core dump data intact.</li>
<li>The application has no limitations other than a reduced total heap size! It may access the report data at any time and use all hardware to send out this report.</li>
<li>After the application clears the report ands reboots, the heap will once again be fully available.</li>
</ol>
<h2><a class="anchor" id="autotoc_md91"></a>
Restrictions on HardFault Entry</h2>
<p>A HardFault is a serious bug and should it happen your application is most likely compromised in some way. Here are some important points to take note of.</p>
<ol type="1">
<li>The HardFault has a hardcoded priority of -1 and only the NMI and the Reset exceptions have a higher priority (-2 and -3). This means ALL device interrupts have a LOWER priority!</li>
<li>The HardFault is a synchronous exception, it will NOT wait for anything to complete, especially not the currently executing interrupt (if any).</li>
<li>There are many reasons for the HardFault exception to be raised (e.g. accessing invalid memory, executing undefined instructions, dividing by zero) making it very difficult to recover in a generic way. It is therefore reasonable to abandon execution (=&gt; reboot) rather than resuming execution in an increasingly unstable application.</li>
</ol>
<p>On HardFault entry, this module calls the function <code><a class="el" href="group__modm__platform__fault.html#gafc7f29452fcc4cd9caf7254c27b10146">modm_hardfault_entry()</a></code> which can be overwritten by the application to put the devices hardware in a safe mode. This can be as simple as disabling power to external components, however, its execution should be strictly time bound and NOT depend on other interrupts completing (they won't), which will cause a deadlock.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__modm__platform__fault.html#gafc7f29452fcc4cd9caf7254c27b10146">modm_hardfault_entry</a>()</div>
<div class="line">{</div>
<div class="line">    Board::MotorDrivers::disable();</div>
<div class="line">    <span class="comment">// return from this function as fast as possible</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>After this function returns, this module will generate the coredump into the heap and reboot the device.</p>
<h2><a class="anchor" id="autotoc_md92"></a>
Reporting the Fault</h2>
<p>In order to recover from the HardFault the device is rebooted with a smaller heap. Once the <code>main()</code> function is reached, the application code should check for <code>FaultReporter::hasReport()</code> and then only initialize the bare minimum of Hardware to send this report to the developer.</p>
<p>To access the report, use the <code>FaultReporter::begin()</code> and <code>FaultReporter::end()</code> functions which return a <code>const_iterator</code> of the actual core dump data, that can be used in a range-based for loop.</p>
<p>Remember to call <code>FaultReporter::clearAndReboot()</code> to clear the report, reboot the device and reclaim the full heap.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (FaultReporter::hasReport()) <span class="comment">// Check first after boot</span></div>
<div class="line">    {</div>
<div class="line">        Application::partialInitialize(); <span class="comment">// Initialize only the necessary</span></div>
<div class="line">        reportBegin();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> uint8_t data : FaultReporter::buildId())</div>
<div class="line">            reportBuildId(data); <span class="comment">// send each byte of Build ID</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> uint8_t data : FaultReporter())</div>
<div class="line">            reportData(data); <span class="comment">// send each byte of data</span></div>
<div class="line">        reportEnd(); <span class="comment">// end the report</span></div>
<div class="line">        FaultReporter::clearAndReboot(); <span class="comment">// clear the report and reboot</span></div>
<div class="line">        <span class="comment">// never reached</span></div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Normal initialization</span></div>
<div class="line">    Application::initialize();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The application is able to use the heap, however, depending on the report size (controllable via the <code>report_level</code> option) the heap may be much smaller then normal. Make sure your application can deal with that.</p>
<p>For complex applications which perhaps communicate asynchronously (CAN, Ethernet, Wireless) it may not be possible to send the report in one piece or at the same time. The report data remains available until you reboot, even after you've cleared the report.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> faultReport{FaultReporter::hasReport()};</div>
<div class="line">    FaultReporter::clear(); <span class="comment">// only clear report but do not reboot</span></div>
<div class="line">    Application::initialize();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        doOtherStuff();</div>
<div class="line">        <span class="keywordflow">if</span> (faultReport and applicationReady)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Still valid AFTER clear, but BEFORE reboot</span></div>
<div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> <span class="keywordtype">id</span> = FaultReporter::buildId();</div>
<div class="line">            <span class="keyword">auto</span> begin = FaultReporter::begin();</div>
<div class="line">            <span class="keyword">auto</span> end = FaultReporter::end();</div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            Application::sendReport(<span class="keywordtype">id</span>, begin, end);</div>
<div class="line">            <span class="comment">// reboot when report has been fully sent</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md93"></a>
Using the Fault Report</h2>
<p>The fault report contains a core dump generated by CrashCatcher and is supposed to be used by CrashDebug to present the memory view to the GDB debugger. For this, you must use the ELF file that corresponds to the devices firmware, as well as copy the coredump data formatted as <em>hexadecimal</em> values into a text file, then call the debugger like this:</p>
<div class="fragment"><div class="line">arm-none-eabi-gdb -tui executable.elf -ex <span class="stringliteral">&quot;set target-charset ASCII&quot;</span> \</div>
<div class="line">    -ex <span class="stringliteral">&quot;target remote | CrashDebug --elf executable.elf --dump coredump.txt&quot;</span></div>
</div><!-- fragment --><p>Note that the <code>FaultReporter::buildId()</code> contains the GNU Build ID, which can help you find the right ELF file:</p>
<div class="fragment"><div class="line">arm-none-eabi-readelf -n executable.elf</div>
<div class="line"> </div>
<div class="line">Displaying notes found in: .build_id</div>
<div class="line">  Owner                 Data size Description</div>
<div class="line">  GNU                  0x00000014 NT_GNU_BUILD_ID (unique build ID bitstring)</div>
<div class="line">    Build ID: 59f08f7a37a7340799d9dba6b0c092bc3c9515c5</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md94"></a>
Post-Mortem Debugging with SCons</h3>
<p>The <code>:build:scons</code> module provides a few helper methods for working with fault reports. You still need to copy the coredump data manually, however, the firmware selection is automated.</p>
<p>The SCons build system will automatically cache the ELF file for the build id for every firmware upload (using <code>scons artifact</code>). When a fault is reported, you can tell SCons the firmware build id and it will use the corresponding ELF file automatically.</p>
<div class="fragment"><div class="line"># Copy data into coredump.txt</div>
<div class="line">touch coredump.txt</div>
<div class="line"># Start postmortem debugging of executable with this build id</div>
<div class="line">scons debug-coredump firmware=59f08f7a37a7340799d9dba6b0c092bc3c9515c5</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md95"></a>
Module Options</h2>
<h3><a class="anchor" id="autotoc_md96"></a>
modm:platform:fault:report_level: Fault Report Level</h3>
<p>This module will try to store as much data as is available in the heap and any leftover data will be discarded. This means the application may not have any heap available after a reboot.</p>
<p>You can control how much data is generated by choosing the right report level:</p>
<ul>
<li>core: Just dumps the core registers, which describe where the fault occurred and why. This is usually less than 250 Bytes.</li>
<li>stack: Dumps the main stack memory. This will get you a full backtrace, but may take a few kB of space.</li>
<li>data: Dumps all memory sections containing static data: <code>.data</code>, <code>.fastdata</code>, <code>.bss</code>. This allows you to see data that isn't related to your current fault location, however, this can take several tens of kB of data.</li>
</ul>
<p>It is strongly recommended to choose the report level that generates less data than you heap size. The <code>scons size</code> output displays this very prominently, if the Data size is smaller than your Heap size, you're good to use the <code>core+stack+data</code> setting:</p>
<div class="fragment"><div class="line">Data:      5.2 KiB (26.0% used) = 2285 B <span class="keyword">static</span> (11.2%) + 3040 B stack (14.8%)</div>
<div class="line">(.bss + .data + .fastdata + .noinit + .stack)</div>
<div class="line"> </div>
<div class="line">Heap:     14.8 KiB (74.0% available)</div>
<div class="line">(.heap1)</div>
</div><!-- fragment --><p>If Heap is smaller than the Data, you may need to switch to using only the <code>core+stack</code> setting:</p>
<div class="fragment"><div class="line">Data:     11.2 KiB (56.0% used) = 8429 B <span class="keyword">static</span> (41.2%) + 3040 B stack (14.8%)</div>
<div class="line">(.bss + .data + .fastdata + .noinit + .stack)</div>
<div class="line"> </div>
<div class="line">Heap:      8.8 KiB (44.0% available)</div>
<div class="line">(.heap1)</div>
</div><!-- fragment --><p>Generated with: <code>core+stack+data in [core, core+stack, core+stack+data]</code> </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafc7f29452fcc4cd9caf7254c27b10146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc7f29452fcc4cd9caf7254c27b10146">&#9670;&nbsp;</a></span>modm_hardfault_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modm_hardfault_entry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called first after a HardFault occurred. Use this to put your hardware in a safe mode, since generating and storing the fault report may take a second or two before rebooting.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is executed in the HardFault interrupt directly, which has the highest interrupt priority, so no other interrupt will be able to fire during this time. BEWARE OF DEADLOCKS!!! </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__modm__platform__fault_html_gafc7f29452fcc4cd9caf7254c27b10146"><div class="ttname"><a href="group__modm__platform__fault.html#gafc7f29452fcc4cd9caf7254c27b10146">modm_hardfault_entry</a></div><div class="ttdeci">void modm_hardfault_entry()</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
