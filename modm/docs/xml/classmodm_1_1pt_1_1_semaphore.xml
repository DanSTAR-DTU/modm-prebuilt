<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classmodm_1_1pt_1_1_semaphore" kind="class" language="C++" prot="public">
    <compoundname>modm::pt::Semaphore</compoundname>
    <includes refid="semaphore_8hpp" local="no">modm/processing/protothread/semaphore.hpp</includes>
      <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classmodm_1_1pt_1_1_semaphore_1ac4de7620941b9ad3b5182f62ed47bdc7" prot="protected" static="no" mutable="no">
        <type>uint16_t</type>
        <definition>uint16_t modm::pt::Semaphore::count</definition>
        <argsstring></argsstring>
        <name>count</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/protothread/semaphore.hpp" line="117" column="1" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/protothread/semaphore.hpp" bodystart="117" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classmodm_1_1pt_1_1_semaphore_1a9e6e0a291ab278780a06bd84512f89ad" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>modm::pt::Semaphore::Semaphore</definition>
        <argsstring>(uint16_t initial)</argsstring>
        <name>Semaphore</name>
        <param>
          <type>uint16_t</type>
          <declname>initial</declname>
        </param>
        <briefdescription>
<para>Create a counting semaphore. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>initial</parametername>
</parameternamelist>
<parameterdescription>
<para>Initial value </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/protothread/semaphore.hpp" line="68" column="1" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/protothread/semaphore.hpp" bodystart="68" bodyend="71"/>
      </memberdef>
      <memberdef kind="function" id="classmodm_1_1pt_1_1_semaphore_1a08448026d80df889cf78d17250526f89" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool modm::pt::Semaphore::acquire</definition>
        <argsstring>()</argsstring>
        <name>acquire</name>
        <briefdescription>
<para>Acquire the semaphore. </para>        </briefdescription>
        <detaileddescription>
<para>The &quot;acquire&quot; or &quot;wait&quot; operation causes the protothread to block while the counter is zero. When the counter reaches a value larger than zero, the protothread will continue.</para><para>Use this always within a PT_WAIT_UNITL() macro inside a modm::pt::Thread::run() method.</para><para><programlisting><codeline><highlight class="normal">PT_WAIT_UNTIL(semaphore.acquire());</highlight></codeline>
</programlisting></para><para><simplesect kind="return"><para><computeroutput>false</computeroutput> if the <ref refid="classmodm_1_1pt_1_1_semaphore" kindref="compound">Semaphore</ref> count not be acquired, <computeroutput>true</computeroutput> if the operation was successful. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/protothread/semaphore.hpp" line="91" column="1" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/protothread/semaphore.hpp" bodystart="91" bodyend="101"/>
      </memberdef>
      <memberdef kind="function" id="classmodm_1_1pt_1_1_semaphore_1a4ad53508e0f6bb5a68e4e6b41782bad0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void modm::pt::Semaphore::release</definition>
        <argsstring>()</argsstring>
        <name>release</name>
        <briefdescription>
<para>Release the semaphore. </para>        </briefdescription>
        <detaileddescription>
<para>The &quot;release&quot; or &quot;signal&quot; operation increments the counter inside the semaphore, which eventually will cause waiting protothreads to continue executing. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/protothread/semaphore.hpp" line="111" column="1" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/protothread/semaphore.hpp" bodystart="111" bodyend="114"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Counting semaphore. </para>    </briefdescription>
    <detaileddescription>
<para>This module implements counting semaphores on top of protothreads. Semaphores are a synchronization primitive that provide two operations: <ref refid="classmodm_1_1pt_1_1_semaphore_1a08448026d80df889cf78d17250526f89" kindref="member">acquire()</ref> and <ref refid="classmodm_1_1pt_1_1_semaphore_1a4ad53508e0f6bb5a68e4e6b41782bad0" kindref="member">release()</ref>. Sometimes these operations are also called <computeroutput>wait</computeroutput> and <computeroutput>signal</computeroutput>. The <ref refid="classmodm_1_1pt_1_1_semaphore_1a08448026d80df889cf78d17250526f89" kindref="member">acquire()</ref> operation checks the semaphore counter and &quot;blocks&quot; the thread if the counter is zero. The <ref refid="classmodm_1_1pt_1_1_semaphore_1a4ad53508e0f6bb5a68e4e6b41782bad0" kindref="member">release()</ref> operation increases the semaphore counter but does not block. If another thread has blocked waiting for the semaphore that is signalled, the blocked thread will become runnable again.</para><para>This class can for example be used for resource limiting or credit tracking:</para><para>Resource limit:<itemizedlist>
<listitem><para><computeroutput>initial</computeroutput> = number of resources</para></listitem><listitem><para><ref refid="classmodm_1_1pt_1_1_semaphore_1a08448026d80df889cf78d17250526f89" kindref="member">acquire()</ref> to gain access to a resource</para></listitem><listitem><para><ref refid="classmodm_1_1pt_1_1_semaphore_1a4ad53508e0f6bb5a68e4e6b41782bad0" kindref="member">release()</ref> to release the resource</para></listitem></itemizedlist>
</para><para>Credit tracking:<itemizedlist>
<listitem><para><computeroutput>initial</computeroutput> = 0</para></listitem><listitem><para><ref refid="classmodm_1_1pt_1_1_semaphore_1a08448026d80df889cf78d17250526f89" kindref="member">acquire()</ref> to increment (credit)</para></listitem><listitem><para><ref refid="classmodm_1_1pt_1_1_semaphore_1a4ad53508e0f6bb5a68e4e6b41782bad0" kindref="member">release()</ref> to consume (debit)</para></listitem></itemizedlist>
</para><para>As protothreads implement a form cooperative multithreading no synchronisation is needed for accessing global variables or for critical sections. Just don&apos;t use <ref refid="group__modm__processing__protothread_1ga7593fae8873b594580319c407dd81ad6" kindref="member">PT_YIELD()</ref> or <ref refid="group__modm__processing__protothread_1ga742a4c6aa99440473f54651233ebd28b" kindref="member">PT_WAIT_UNTIL()</ref> inside a critical sections and you&apos;re fine.</para><para>Therefore there&apos;s no Mutex implementation, it isn&apos;t needed. </para>    </detaileddescription>
    <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/protothread/semaphore.hpp" line="61" column="1" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/protothread/semaphore.hpp" bodystart="60" bodyend="118"/>
    <listofallmembers>
      <member refid="classmodm_1_1pt_1_1_semaphore_1a08448026d80df889cf78d17250526f89" prot="public" virt="non-virtual"><scope>modm::pt::Semaphore</scope><name>acquire</name></member>
      <member refid="classmodm_1_1pt_1_1_semaphore_1ac4de7620941b9ad3b5182f62ed47bdc7" prot="protected" virt="non-virtual"><scope>modm::pt::Semaphore</scope><name>count</name></member>
      <member refid="classmodm_1_1pt_1_1_semaphore_1a4ad53508e0f6bb5a68e4e6b41782bad0" prot="public" virt="non-virtual"><scope>modm::pt::Semaphore</scope><name>release</name></member>
      <member refid="classmodm_1_1pt_1_1_semaphore_1a9e6e0a291ab278780a06bd84512f89ad" prot="public" virt="non-virtual"><scope>modm::pt::Semaphore</scope><name>Semaphore</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
