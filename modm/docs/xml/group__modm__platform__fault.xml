<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="group__modm__platform__fault" kind="group">
    <compoundname>modm_platform_fault</compoundname>
    <title>ARM Cortex-M Fault Reporters</title>
    <innerclass refid="classmodm_1_1platform_1_1_fault_reporter" prot="public">modm::platform::FaultReporter</innerclass>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__modm__platform__fault_1gafc7f29452fcc4cd9caf7254c27b10146" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void modm_hardfault_entry</definition>
        <argsstring>()</argsstring>
        <name>modm_hardfault_entry</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Called first after a HardFault occurred. Use this to put your hardware in a safe mode, since generating and storing the fault report may take a second or two before rebooting.</para><para><simplesect kind="warning"><para>This is executed in the HardFault interrupt directly, which has the highest interrupt priority, so no other interrupt will be able to fire during this time. BEWARE OF DEADLOCKS!!! </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Documents/DanStar/Software-dolken/modm-prebuilt/modm/src/modm/platform/fault/fault.hpp" line="28" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>This module manages data storage for core dumps provided by the <computeroutput>:crashcatcher</computeroutput> module to investigate HardFault events via offline post-mortem debugging. The data is stored in the volatile memory designated for the heap.</para><para>This works as follows:</para><para><orderedlist>
<listitem><para>A HardFault occurs and is intercepted by CrashCatcher.</para></listitem><listitem><para>CrashCatcher calls into this module to store the core dump in the heap as defined by the linkerscript&apos;s <computeroutput>.table.heap</computeroutput> section, thus effectively overwriting the heap, then reboots the device.</para></listitem><listitem><para>On reboot, only the remaining heap memory is initialized, leaving the core dump data intact.</para></listitem><listitem><para>The application has no limitations other than a reduced total heap size! It may access the report data at any time and use all hardware to send out this report.</para></listitem><listitem><para>After the application clears the report ands reboots, the heap will once again be fully available.</para></listitem></orderedlist>
</para><para><heading level="2">Restrictions on HardFault Entry</heading>
</para><para>A HardFault is a serious bug and should it happen your application is most likely compromised in some way. Here are some important points to take note of.</para><para><orderedlist>
<listitem><para>The HardFault has a hardcoded priority of -1 and only the NMI and the Reset exceptions have a higher priority (-2 and -3). This means ALL device interrupts have a LOWER priority!</para></listitem><listitem><para>The HardFault is a synchronous exception, it will NOT wait for anything to complete, especially not the currently executing interrupt (if any).</para></listitem><listitem><para>There are many reasons for the HardFault exception to be raised (e.g. accessing invalid memory, executing undefined instructions, dividing by zero) making it very difficult to recover in a generic way. It is therefore reasonable to abandon execution (=&gt; reboot) rather than resuming execution in an increasingly unstable application.</para></listitem></orderedlist>
</para><para>On HardFault entry, this module calls the function <computeroutput><ref refid="group__modm__platform__fault_1gafc7f29452fcc4cd9caf7254c27b10146" kindref="member">modm_hardfault_entry()</ref></computeroutput> which can be overwritten by the application to put the devices hardware in a safe mode. This can be as simple as disabling power to external components, however, its execution should be strictly time bound and NOT depend on other interrupts completing (they won&apos;t), which will cause a deadlock.</para><para><programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__modm__platform__fault_1gafc7f29452fcc4cd9caf7254c27b10146" kindref="member">modm_hardfault_entry</ref>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Board::MotorDrivers::disable();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>return<sp/>from<sp/>this<sp/>function<sp/>as<sp/>fast<sp/>as<sp/>possible</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>After this function returns, this module will generate the coredump into the heap and reboot the device.</para><para><heading level="2">Reporting the Fault</heading>
</para><para>In order to recover from the HardFault the device is rebooted with a smaller heap. Once the <computeroutput>main()</computeroutput> function is reached, the application code should check for <computeroutput>FaultReporter::hasReport()</computeroutput> and then only initialize the bare minimum of Hardware to send this report to the developer.</para><para>To access the report, use the <computeroutput>FaultReporter::begin()</computeroutput> and <computeroutput>FaultReporter::end()</computeroutput> functions which return a <computeroutput>const_iterator</computeroutput> of the actual core dump data, that can be used in a range-based for loop.</para><para>Remember to call <computeroutput>FaultReporter::clearAndReboot()</computeroutput> to clear the report, reboot the device and reclaim the full heap.</para><para><programlisting><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(FaultReporter::hasReport())<sp/></highlight><highlight class="comment">//<sp/>Check<sp/>first<sp/>after<sp/>boot</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Application::partialInitialize();<sp/></highlight><highlight class="comment">//<sp/>Initialize<sp/>only<sp/>the<sp/>necessary</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reportBegin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint8_t<sp/>data<sp/>:<sp/>FaultReporter::buildId())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reportBuildId(data);<sp/></highlight><highlight class="comment">//<sp/>send<sp/>each<sp/>byte<sp/>of<sp/>Build<sp/>ID</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint8_t<sp/>data<sp/>:<sp/>FaultReporter())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reportData(data);<sp/></highlight><highlight class="comment">//<sp/>send<sp/>each<sp/>byte<sp/>of<sp/>data</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reportEnd();<sp/></highlight><highlight class="comment">//<sp/>end<sp/>the<sp/>report</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FaultReporter::clearAndReboot();<sp/></highlight><highlight class="comment">//<sp/>clear<sp/>the<sp/>report<sp/>and<sp/>reboot</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>never<sp/>reached</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Normal<sp/>initialization</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Application::initialize();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The application is able to use the heap, however, depending on the report size (controllable via the <computeroutput>report_level</computeroutput> option) the heap may be much smaller then normal. Make sure your application can deal with that.</para><para>For complex applications which perhaps communicate asynchronously (CAN, Ethernet, Wireless) it may not be possible to send the report in one piece or at the same time. The report data remains available until you reboot, even after you&apos;ve cleared the report.</para><para><programlisting><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>faultReport{FaultReporter::hasReport()};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FaultReporter::clear();<sp/></highlight><highlight class="comment">//<sp/>only<sp/>clear<sp/>report<sp/>but<sp/>do<sp/>not<sp/>reboot</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Application::initialize();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>doOtherStuff();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(faultReport<sp/>and<sp/>applicationReady)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Still<sp/>valid<sp/>AFTER<sp/>clear,<sp/>but<sp/>BEFORE<sp/>reboot</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal"><sp/>=<sp/>FaultReporter::buildId();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>begin<sp/>=<sp/>FaultReporter::begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>end<sp/>=<sp/>FaultReporter::end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Application::sendReport(</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,<sp/>begin,<sp/>end);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>reboot<sp/>when<sp/>report<sp/>has<sp/>been<sp/>fully<sp/>sent</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><heading level="2">Using the Fault Report</heading>
</para><para>The fault report contains a core dump generated by CrashCatcher and is supposed to be used by CrashDebug to present the memory view to the GDB debugger. For this, you must use the ELF file that corresponds to the devices firmware, as well as copy the coredump data formatted as <emphasis>hexadecimal</emphasis> values into a text file, then call the debugger like this:</para><para><programlisting><codeline><highlight class="normal">arm-none-eabi-gdb<sp/>-tui<sp/>executable.elf<sp/>-ex<sp/>&quot;set<sp/>target-charset<sp/>ASCII&quot;<sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>-ex<sp/>&quot;target<sp/>remote<sp/>|<sp/>CrashDebug<sp/>--elf<sp/>executable.elf<sp/>--dump<sp/>coredump.txt&quot;</highlight></codeline>
</programlisting></para><para>Note that the <computeroutput>FaultReporter::buildId()</computeroutput> contains the GNU Build ID, which can help you find the right ELF file:</para><para><programlisting><codeline><highlight class="normal">arm-none-eabi-readelf<sp/>-n<sp/>executable.elf</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Displaying<sp/>notes<sp/>found<sp/>in:<sp/>.build_id</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Owner<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Data<sp/>size<sp/>Description</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GNU<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0x00000014<sp/>NT_GNU_BUILD_ID<sp/>(unique<sp/>build<sp/>ID<sp/>bitstring)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Build<sp/>ID:<sp/>59f08f7a37a7340799d9dba6b0c092bc3c9515c5</highlight></codeline>
</programlisting></para><para><heading level="3">Post-Mortem Debugging with SCons</heading>
</para><para>The <computeroutput>:build:scons</computeroutput> module provides a few helper methods for working with fault reports. You still need to copy the coredump data manually, however, the firmware selection is automated.</para><para>The SCons build system will automatically cache the ELF file for the build id for every firmware upload (using <computeroutput>scons artifact</computeroutput>). When a fault is reported, you can tell SCons the firmware build id and it will use the corresponding ELF file automatically.</para><para><programlisting><codeline><highlight class="normal">#<sp/>Copy<sp/>data<sp/>into<sp/>coredump.txt</highlight></codeline>
<codeline><highlight class="normal">touch<sp/>coredump.txt</highlight></codeline>
<codeline><highlight class="normal">#<sp/>Start<sp/>postmortem<sp/>debugging<sp/>of<sp/>executable<sp/>with<sp/>this<sp/>build<sp/>id</highlight></codeline>
<codeline><highlight class="normal">scons<sp/>postmortem<sp/>firmware=59f08f7a37a7340799d9dba6b0c092bc3c9515c5</highlight></codeline>
</programlisting> </para>    </detaileddescription>
  </compounddef>
</doxygen>
