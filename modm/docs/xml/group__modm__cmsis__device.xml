<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="group__modm__cmsis__device" kind="group">
    <compoundname>modm_cmsis_device</compoundname>
    <title>STM32 CMSIS Headers</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>This module wraps <ulink url="https://github.com/modm-io/cmsis-header-stm32">the CMSIS headers for STM32 devices</ulink> and provides the header file and CPP definitions for accessing the <computeroutput>modm:target</computeroutput> peripherals. Specifically, it copies the target header file which provides the CMSIS implementation of the target&apos;s language interface for its memory-mapped peripherals.</para>
<para><xrefsect id="bug_1_bug000001"><xreftitle>Bug</xreftitle><xrefdescription><para>&quot;Discrepancies between documentation and headers&quot; These CMSIS headers should reflect what&apos;s written in the documentation, however, in our experience there may be small differences in naming, behavior and availability between it and this implementation. Since ST is not interested in addressing these issues, please contribute <ulink url="https://github.com/modm-io/cmsis-header-stm32/tree/master/patches">to our patch list</ulink>.</para>
</xrefdescription></xrefsect></para>
<para>The generated header file <computeroutput><ref refid="device_8hpp" kindref="compound">modm/platform/device.hpp</ref></computeroutput> contains the necessary target define <computeroutput>STM32{FAMILY}{NAME}xx</computeroutput> or similar and includes the <computeroutput>modm:target</computeroutput>-specific header.</para>
<para><simplesect kind="note"><para>&quot;Include only `modm/platform/device.hpp`!&quot; This file is only included by interface implementations inside the <computeroutput>modm/platform</computeroutput> folder! If you need to implement your own drivers, include only this file.</para>
</simplesect>
<heading level="2">CMSIS Compliance</heading>
</para>
<para>modm implements the target specific CMSIS functionality itself, without using the CMSIS interface. This is necessary to provide similar functionality on non-Cortex-M based targets.</para>
<para>Specifically, these functions are not implemented:</para>
<para><itemizedlist>
<listitem><para><computeroutput>uint32_t SystemCoreClock</computeroutput> and <computeroutput>void SystemCoreClockUpdate()</computeroutput>: please use <computeroutput>modm::clock::f_cpu</computeroutput> as defined in the <computeroutput>modm:architecture:clock</computeroutput> module.</para>
</listitem><listitem><para><computeroutput>void SystemInit()</computeroutput>: modm defines its own startup architecture, see the <computeroutput>modm:platform:core</computeroutput> module for details.</para>
</listitem></itemizedlist>
</para>
<para><heading level="2">Debugging Peripherals</heading>
</para>
<para>When debugging with GDB, it can sometimes be difficult to access peripherals, due to the CMSIS implementation with CPP defines and GCC optimization flags. Depending on these circumstances, GDB may only &quot;see&quot; a peripheral in a certain context, which can make the debugging experience quite frustrating.</para>
<para>To aid this, we generate a linkerscript fragment and source file, which place the peripherals memory as real objects in the peripheral memory space. You can then access these peripherals inside GDB at any time, regardless of context and build profile setting:</para>
<para><programlisting><codeline><highlight class="normal">(gdb)<sp/>p/x<sp/>*GPIOB</highlight></codeline>
<codeline><highlight class="normal">$1<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MODER<sp/>=<sp/>0xaa0280,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OTYPER<sp/>=<sp/>0x300,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OSPEEDR<sp/>=<sp/>0x2a00c0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PUPDR<sp/>=<sp/>0x400100,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IDR<sp/>=<sp/>0xfd0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ODR<sp/>=<sp/>0x100,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>BSRR<sp/>=<sp/>0x0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>LCKR<sp/>=<sp/>0x0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AFR<sp/>=<sp/>{0x0,<sp/>0x7744}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>This does not have any effect on your firmware!** It is purely a debug helper feature and none of these definitions make it into the executable.</para>
<para><simplesect kind="note"><para>&quot;Beware read/write side-effects&quot; When debugging be aware of the side-effects that your read or write to a peripheral memory location can have. It&apos;s fairly obvious that a write may have consequences, but also reads can modify peripheral state, for example, a hardware FIFO buffer may pop the queue if your read the top of it. </para>
</simplesect>
</para>
    </detaileddescription>
  </compounddef>
</doxygen>
