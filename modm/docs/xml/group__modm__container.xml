<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="group__modm__container" kind="group">
    <compoundname>modm_container</compoundname>
    <title>Containers</title>
    <innerclass refid="classmodm_1_1_bounded_deque" prot="public">modm::BoundedDeque</innerclass>
    <innerclass refid="classmodm_1_1_doubly_linked_list" prot="public">modm::DoublyLinkedList</innerclass>
    <innerclass refid="classmodm_1_1_dynamic_array" prot="public">modm::DynamicArray</innerclass>
    <innerclass refid="classmodm_1_1_linked_list" prot="public">modm::LinkedList</innerclass>
    <innerclass refid="classmodm_1_1_pair" prot="public">modm::Pair</innerclass>
    <innerclass refid="classmodm_1_1_queue" prot="public">modm::Queue</innerclass>
    <innerclass refid="classmodm_1_1_bounded_queue" prot="public">modm::BoundedQueue</innerclass>
    <innerclass refid="classmodm_1_1_smart_pointer" prot="public">modm::SmartPointer</innerclass>
    <innerclass refid="classmodm_1_1_stack" prot="public">modm::Stack</innerclass>
    <innerclass refid="classmodm_1_1_bounded_stack" prot="public">modm::BoundedStack</innerclass>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>A container is a holder object that stores a collection other objects (its elements). They are implemented as class templates, which allows a great flexibility in the types supported as elements.</para><para>Many containers have several member functions in common, and share functionalities. The decision of which type of container to use for a specific need does not generally depend only on the functionality offered by the container, but also on the efficiency of some of its members (complexity). This is especially true for sequence containers, which offer different trade-offs in complexity between inserting/removing elements and accessing them.</para><para><computeroutput><ref refid="classmodm_1_1_stack" kindref="compound">modm::Stack</ref></computeroutput> and <computeroutput><ref refid="classmodm_1_1_queue" kindref="compound">modm::Queue</ref></computeroutput> are implemented as container adapters. Container adapters are not full container classes, but classes that provide a specific interface relying on an object of one of the container classes (such as <computeroutput><ref refid="classmodm_1_1_bounded_deque" kindref="compound">modm::BoundedDeque</ref></computeroutput> or <computeroutput><ref refid="classmodm_1_1_linked_list" kindref="compound">modm::LinkedList</ref></computeroutput>) to handle the elements. The underlying container is encapsulated in such a way that its elements are accessed by the members of the container class independently of the underlying container class used.</para><para>Sequence containers:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classmodm_1_1_dynamic_array" kindref="compound">modm::DynamicArray</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classmodm_1_1_linked_list" kindref="compound">modm::LinkedList</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classmodm_1_1_doubly_linked_list" kindref="compound">modm::DoublyLinkedList</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classmodm_1_1_bounded_deque" kindref="compound">modm::BoundedDeque</ref></computeroutput></para></listitem></itemizedlist>
</para><para>Container adapters:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classmodm_1_1_queue" kindref="compound">modm::Queue</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classmodm_1_1_stack" kindref="compound">modm::Stack</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classmodm_1_1_bounded_stack" kindref="compound">modm::BoundedStack</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classmodm_1_1_bounded_queue" kindref="compound">modm::BoundedQueue</ref></computeroutput></para></listitem></itemizedlist>
</para><para>Other:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classmodm_1_1_smart_pointer" kindref="compound">modm::SmartPointer</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classmodm_1_1_pair" kindref="compound">modm::Pair</ref></computeroutput></para></listitem></itemizedlist>
</para><para>Two special containers hiding in the <computeroutput>modm:architecture:atomic</computeroutput> module:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classmodm_1_1atomic_1_1_queue" kindref="compound">modm::atomic::Queue</ref></computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classmodm_1_1atomic_1_1_container" kindref="compound">modm::atomic::Container</ref></computeroutput></para></listitem></itemizedlist>
</para><para>The first is a simple, interrupt-safe queue (but only for the AVRs). Whenever you need to exchange data between a interrupt routine and the normal program consider using this queue.</para><para>The atomic container wraps objects and provides atomic access to them. This comes in handy when simple objects are accessed by an interrupt and the main program. The container provides secure access without much work in this case.</para><para><heading level="2">Generic Interface</heading>
</para><para>All implementation share a common set of function. Not every container implement every one of it, only a subset which is sufficient for the container.</para><para><itemizedlist>
<listitem><para>append</para></listitem><listitem><para>prepend</para></listitem><listitem><para>(insert)</para></listitem><listitem><para>removeFront</para></listitem><listitem><para>removeBack</para></listitem><listitem><para>(remove)</para></listitem><listitem><para>getFront</para></listitem><listitem><para>getBack</para></listitem><listitem><para>push (only Stack and Queue)</para></listitem><listitem><para>pop (only Stack and Queue)</para></listitem><listitem><para>get (only Stack and Queue)</para></listitem><listitem><para>at</para></listitem><listitem><para>operator[]</para></listitem><listitem><para>clear</para></listitem><listitem><para>isEmpty</para></listitem><listitem><para>isFull</para></listitem><listitem><para>getSize</para></listitem><listitem><para>getMaxSize</para></listitem><listitem><para>getCapacity </para></listitem></itemizedlist>
</para>    </detaileddescription>
  </compounddef>
</doxygen>
