<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="group__modm__processing__timer" kind="group">
    <compoundname>modm_processing_timer</compoundname>
    <title>Software Timers</title>
    <innerclass refid="classmodm_1_1_generic_periodic_timer" prot="public">modm::GenericPeriodicTimer</innerclass>
    <innerclass refid="classmodm_1_1_generic_timeout" prot="public">modm::GenericTimeout</innerclass>
    <innerclass refid="classmodm_1_1_generic_timestamp" prot="public">modm::GenericTimestamp</innerclass>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__modm__processing__timer_1ga619927ca5dffdb82e1c77b41941d63cd" prot="public" static="no" strong="yes">
        <type>uint8_t</type>
        <name>PeriodicTimerState</name>
        <enumvalue id="group__modm__processing__timer_1gga619927ca5dffdb82e1c77b41941d63cdac23e2b09ebe6bf4cb5e2a9abe85c0be2" prot="public">
          <name>Stopped</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__modm__processing__timer_1gga619927ca5dffdb82e1c77b41941d63cda24fe48030f7d3097d5882535b04c3fa8" prot="public">
          <name>Expired</name>
          <initializer>= 0b010</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__modm__processing__timer_1gga619927ca5dffdb82e1c77b41941d63cdadb4e3578582cd2cd9c679eef11172d83" prot="public">
          <name>Armed</name>
          <initializer>= 0b100</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Possible states of a timer </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/amar/classes/danstar/modm-prebuilt/modm/src/modm/processing/timer/periodic_timer.hpp" line="28" column="1" bodyfile="/home/amar/classes/danstar/modm-prebuilt/modm/src/modm/processing/timer/periodic_timer.hpp" bodystart="26" bodyend="32"/>
      </memberdef>
      <memberdef kind="enum" id="group__modm__processing__timer_1gacc7987b8fe7071d9cd993829ee005298" prot="public" static="no" strong="yes">
        <type>uint8_t</type>
        <name>TimeoutState</name>
        <enumvalue id="group__modm__processing__timer_1ggacc7987b8fe7071d9cd993829ee005298ac23e2b09ebe6bf4cb5e2a9abe85c0be2" prot="public">
          <name>Stopped</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__modm__processing__timer_1ggacc7987b8fe7071d9cd993829ee005298a24fe48030f7d3097d5882535b04c3fa8" prot="public">
          <name>Expired</name>
          <initializer>= 0b010</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__modm__processing__timer_1ggacc7987b8fe7071d9cd993829ee005298adb4e3578582cd2cd9c679eef11172d83" prot="public">
          <name>Armed</name>
          <initializer>= 0b100</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Possible states of a timeout </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/amar/classes/danstar/modm-prebuilt/modm/src/modm/processing/timer/timeout.hpp" line="30" column="1" bodyfile="/home/amar/classes/danstar/modm-prebuilt/modm/src/modm/processing/timer/timeout.hpp" bodystart="28" bodyend="34"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__modm__processing__timer_1ga3d265ef7be475824993d2f3f38e0abec" prot="public" static="no">
        <type>GenericPeriodicTimer&lt; ::<ref refid="classmodm_1_1_clock" kindref="compound">modm::Clock</ref>, ShortTimestamp &gt;</type>
        <definition>using modm::ShortPeriodicTimer = typedef GenericPeriodicTimer&lt; ::modm::Clock, ShortTimestamp&gt;</definition>
        <argsstring></argsstring>
        <name>ShortPeriodicTimer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Periodic software timer for up to 32 seconds with millisecond resolution.</para>
<para>Extra care must be taken when not calling the isExpired() method for more than 32 seconds. Due to an overflow in the implementation this might add an additional delay of up to 32s ticks in the worst case. Always call restart() or restart(time) before reusing the timer to avoid this behaviour.</para>
<para>If you need a longer time period, use PeriodicTimer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/amar/classes/danstar/modm-prebuilt/modm/src/modm/processing/timer/periodic_timer.hpp" line="105" column="1" bodyfile="/home/amar/classes/danstar/modm-prebuilt/modm/src/modm/processing/timer/periodic_timer.hpp" bodystart="105" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__modm__processing__timer_1gafd9875f046c1bd3358612162e7ad8839" prot="public" static="no">
        <type>GenericPeriodicTimer&lt; ::<ref refid="classmodm_1_1_clock" kindref="compound">modm::Clock</ref>, Timestamp &gt;</type>
        <definition>using modm::PeriodicTimer = typedef GenericPeriodicTimer&lt; ::modm::Clock, Timestamp&gt;</definition>
        <argsstring></argsstring>
        <name>PeriodicTimer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Periodic software timer for up to 24 days with millisecond resolution. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/amar/classes/danstar/modm-prebuilt/modm/src/modm/processing/timer/periodic_timer.hpp" line="109" column="1" bodyfile="/home/amar/classes/danstar/modm-prebuilt/modm/src/modm/processing/timer/periodic_timer.hpp" bodystart="109" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__modm__processing__timer_1ga5942cb6169725e55e37487efc326851b" prot="public" static="no">
        <type>GenericTimeout&lt; ::<ref refid="classmodm_1_1_clock" kindref="compound">modm::Clock</ref>, ShortTimestamp &gt;</type>
        <definition>using modm::ShortTimeout = typedef GenericTimeout&lt; ::modm::Clock, ShortTimestamp&gt;</definition>
        <argsstring></argsstring>
        <name>ShortTimeout</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Software timeout for up to 32 seconds with millisecond resolution.</para>
<para>Extra care must be taken when not calling the isExpired() method for more than 32 seconds. Due to an overflow in the implementation this might add an additional delay of up to 32s ticks in the worst case. Always call restart(time) before reusing the timer to avoid this behaviour.</para>
<para>If you need a longer time period, use Timeout. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/amar/classes/danstar/modm-prebuilt/modm/src/modm/processing/timer/timeout.hpp" line="134" column="1" bodyfile="/home/amar/classes/danstar/modm-prebuilt/modm/src/modm/processing/timer/timeout.hpp" bodystart="134" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__modm__processing__timer_1ga527fc57fdfcde22d06c2c1b913ec4d58" prot="public" static="no">
        <type>GenericTimeout&lt; ::<ref refid="classmodm_1_1_clock" kindref="compound">modm::Clock</ref>, Timestamp &gt;</type>
        <definition>using modm::Timeout = typedef GenericTimeout&lt; ::modm::Clock, Timestamp&gt;</definition>
        <argsstring></argsstring>
        <name>Timeout</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Software timeout for up to 24 days with millisecond resolution. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/amar/classes/danstar/modm-prebuilt/modm/src/modm/processing/timer/timeout.hpp" line="138" column="1" bodyfile="/home/amar/classes/danstar/modm-prebuilt/modm/src/modm/processing/timer/timeout.hpp" bodystart="138" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__modm__processing__timer_1ga842ffd54d7e497f11c85118cd2a52570" prot="public" static="no">
        <type>GenericTimestamp&lt; uint16_t &gt;</type>
        <definition>using modm::ShortTimestamp = typedef GenericTimestamp&lt;uint16_t&gt;</definition>
        <argsstring></argsstring>
        <name>ShortTimestamp</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>16bit timestamp, which can hold up to 65 seconds at millisecond resolution. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/amar/classes/danstar/modm-prebuilt/modm/src/modm/processing/timer/timestamp.hpp" line="114" column="1" bodyfile="/home/amar/classes/danstar/modm-prebuilt/modm/src/modm/processing/timer/timestamp.hpp" bodystart="114" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__modm__processing__timer_1ga8f3b60fc7930db595007904dc1e2090d" prot="public" static="no">
        <type>GenericTimestamp&lt; uint32_t &gt;</type>
        <definition>using modm::Timestamp = typedef GenericTimestamp&lt;uint32_t&gt;</definition>
        <argsstring></argsstring>
        <name>Timestamp</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>32bit timestamp, which can hold up to 49 days at millisecond resolution. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/amar/classes/danstar/modm-prebuilt/modm/src/modm/processing/timer/timestamp.hpp" line="118" column="1" bodyfile="/home/amar/classes/danstar/modm-prebuilt/modm/src/modm/processing/timer/timestamp.hpp" bodystart="118" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>An implementation of lightweight software timeouts and periodic timers.</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__modm__processing__timer_1ga8f3b60fc7930db595007904dc1e2090d" kindref="member">modm::Timestamp</ref></computeroutput> containing a time in millisecond resolution up to 49 days.</para>
</listitem><listitem><para><computeroutput><ref refid="group__modm__processing__timer_1ga527fc57fdfcde22d06c2c1b913ec4d58" kindref="member">modm::Timeout</ref></computeroutput> for timeouts up to 24 days.</para>
</listitem><listitem><para><computeroutput><ref refid="group__modm__processing__timer_1gafd9875f046c1bd3358612162e7ad8839" kindref="member">modm::PeriodicTimer</ref></computeroutput> for periodic timeouts up to 24 days periods.</para>
</listitem></itemizedlist>
</para>
<para>There are also 16-bit versions of these, in case you need to preserve memory:</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__modm__processing__timer_1ga842ffd54d7e497f11c85118cd2a52570" kindref="member">modm::ShortTimestamp</ref></computeroutput> containing a time in millisecond resolution up to 65 seconds.</para>
</listitem><listitem><para><computeroutput><ref refid="group__modm__processing__timer_1ga5942cb6169725e55e37487efc326851b" kindref="member">modm::ShortTimeout</ref></computeroutput> for timeouts up to 32 seconds.</para>
</listitem><listitem><para><computeroutput><ref refid="group__modm__processing__timer_1ga3d265ef7be475824993d2f3f38e0abec" kindref="member">modm::ShortPeriodicTimer</ref></computeroutput> for periodic timeouts up to 32 second periods.</para>
</listitem></itemizedlist>
</para>
<para>These classes default to using <computeroutput><ref refid="classmodm_1_1_clock" kindref="compound">modm::Clock</ref></computeroutput>, which must be implemented on your system to return a time with millisecond resolution.</para>
<para>You may also create your own timers with custom time bases and resolutions using these classes:</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="classmodm_1_1_generic_timestamp" kindref="compound">modm::GenericTimestamp</ref></computeroutput>.</para>
</listitem><listitem><para><computeroutput><ref refid="classmodm_1_1_generic_timeout" kindref="compound">modm::GenericTimeout</ref></computeroutput>.</para>
</listitem><listitem><para><computeroutput><ref refid="classmodm_1_1_generic_periodic_timer" kindref="compound">modm::GenericPeriodicTimer</ref></computeroutput>.</para>
</listitem></itemizedlist>
</para>
<para><simplesect kind="warning"><para>Never use these classes when a precise timebase is needed!</para>
</simplesect>
<heading level="2">Timeouts</heading>
</para>
<para>The <computeroutput><ref refid="classmodm_1_1_generic_timeout" kindref="compound">modm::GenericTimeout</ref></computeroutput> classes allow for a signal to be generated after a period of time, which can also be used to execute code once after timeout expiration.</para>
<para>Its behavior can be described by the following annotated waveform:</para>
<para><itemizedlist>
<listitem><para>C: Default Constructor</para>
</listitem><listitem><para>S: (Re-)Start timeout</para>
</listitem><listitem><para>E: Timeout Expired</para>
</listitem><listitem><para>H: Code handler (<computeroutput>execute()</computeroutput> returned <computeroutput>true</computeroutput>)</para>
</listitem><listitem><para>P: Stop timeout</para>
</listitem></itemizedlist>
</para>
<para><programlisting><codeline><highlight class="normal">Event:<sp/><sp/><sp/><sp/>C<sp/><sp/><sp/><sp/><sp/><sp/>S<sp/><sp/><sp/><sp/><sp/><sp/>E<sp/><sp/><sp/><sp/><sp/>H<sp/><sp/><sp/><sp/><sp/><sp/><sp/>P<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>S<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>E<sp/>H</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_____________<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>______________</highlight></codeline>
<codeline><highlight class="normal">Expired:<sp/><sp/>______________/<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\_______________________/<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>______<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__________</highlight></codeline>
<codeline><highlight class="normal">Armed:<sp/><sp/><sp/><sp/>_______/<sp/><sp/><sp/><sp/><sp/><sp/>\__________________________/<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\______________...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_______<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>____________</highlight></codeline>
<codeline><highlight class="normal">Stopped:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\____________________/<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\_________________________...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_</highlight></codeline>
<codeline><highlight class="normal">Handle:<sp/><sp/><sp/>___________________/<sp/>\_______________________________/<sp/>\___________...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Remaining:<sp/><sp/><sp/>0<sp/><sp/>|<sp/><sp/><sp/>+<sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/>-<sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/>0<sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/>+<sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/>-</highlight></codeline>
</programlisting></para>
<para>The default constructor initializes the timeout in the <computeroutput>Stopped</computeroutput> state, in which <computeroutput>isExpired()</computeroutput> and <computeroutput>execute()</computeroutput> never return <computeroutput>true</computeroutput>. If you need a timeout to expire immidiately after construction, you need to explicitly initialize the constructor with time <computeroutput>0</computeroutput>, which has the same behavior as <computeroutput>restart(0)</computeroutput>.</para>
<para>If you want to execute code once after the timeout expired, poll the <computeroutput>execute()</computeroutput> method, which returns <computeroutput>true</computeroutput> exactly once after expiration.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(timeout.execute())</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>called<sp/>once<sp/>after<sp/>timeout</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Led::toggle();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Be aware, however, that since this method is polled, it cannot execute exactly at the time of expiration, but some time after expiration, as indicated in the above waveform graph.</para>
<para>The <computeroutput>remaining()</computeroutput> time until expiration is signed positive before, and negative after expiration. This means <computeroutput>Clock::now() + Timeout::remaining()</computeroutput> will yield the timestamp of the expiration. If the timeout is stopped, <computeroutput>remaining()</computeroutput> returns zero.</para>
<para><heading level="2">Periodic Timers</heading>
</para>
<para>The <computeroutput><ref refid="classmodm_1_1_generic_periodic_timer" kindref="compound">modm::GenericPeriodicTimer</ref></computeroutput> class allows for periodic code execution.</para>
<para>Its behavior can be described by the following annotated waveform:</para>
<para><itemizedlist>
<listitem><para>C: Constructor</para>
</listitem><listitem><para>S: (Re-)Start timer</para>
</listitem><listitem><para>I: Period interval</para>
</listitem><listitem><para>H: Code handler (<computeroutput>execute()</computeroutput> returned <computeroutput>true</computeroutput>)</para>
</listitem><listitem><para>P: Stop timer</para>
</listitem></itemizedlist>
</para>
<para><programlisting><codeline><highlight class="normal">Event:<sp/><sp/><sp/><sp/>C<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IH<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>I<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>I<sp/><sp/>H<sp/><sp/><sp/><sp/><sp/><sp/>I<sp/><sp/>S<sp/><sp/><sp/><sp/>IH<sp/><sp/><sp/>I<sp/><sp/><sp/><sp/>IH<sp/><sp/>P</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_____________<sp/><sp/><sp/><sp/><sp/><sp/><sp/>__<sp/><sp/><sp/><sp/><sp/><sp/>_<sp/><sp/><sp/><sp/>______</highlight></codeline>
<codeline><highlight class="normal">Expired:<sp/><sp/>__________/<sp/>\_______/<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\_____/<sp/><sp/>\____/<sp/>\__/<sp/><sp/><sp/><sp/><sp/><sp/>\____...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__________<sp/><sp/><sp/>_______<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_____<sp/><sp/><sp/><sp/>____<sp/><sp/><sp/>__<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_</highlight></codeline>
<codeline><highlight class="normal">Armed:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\_/<sp/><sp/><sp/><sp/><sp/><sp/><sp/>\_____________/<sp/><sp/><sp/><sp/><sp/>\__/<sp/><sp/><sp/><sp/>\_/<sp/><sp/>\______/<sp/>\__...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__</highlight></codeline>
<codeline><highlight class="normal">Stopped:<sp/><sp/>______________________________________________________________/<sp/><sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_</highlight></codeline>
<codeline><highlight class="normal">Handle:<sp/><sp/><sp/>__________/<sp/>\___________________/<sp/>\_____________/<sp/>\_______/<sp/>\____...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Remaining:<sp/><sp/><sp/><sp/><sp/>+<sp/><sp/><sp/><sp/>|0|<sp/><sp/><sp/>+<sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/>-<sp/><sp/><sp/><sp/><sp/>|0|<sp/><sp/>+<sp/><sp/>|<sp/>-|<sp/><sp/>+<sp/>|0|<sp/>+|<sp/>-<sp/><sp/>|0|+|<sp/>0</highlight></codeline>
</programlisting></para>
<para>If you want to execute code once per period interval, poll the <computeroutput>execute()</computeroutput> method, which returns <computeroutput>true</computeroutput> exactly once after expiration.</para>
<para><programlisting><codeline><highlight class="normal">if<sp/>(timer.execute())</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>periodically<sp/>called<sp/>once</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Led::toggle();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Be aware, however, that since this method is polled, it cannot execute exactly at the time of expiration, but some time after expiration, as indicated in the above waveform graph. If one or several periods are missed when polling <computeroutput>execute()</computeroutput>, these code executions are discarded and will not be caught up. Instead, <computeroutput>execute()</computeroutput> returns <computeroutput>true</computeroutput> once and then reschedules itself for the next period, without any period skewing.</para>
<para><simplesect kind="warning"><para>Never use this class when a precise timebase is needed!</para>
</simplesect>
Notice, that the <computeroutput>PeriodicTimerState::Expired</computeroutput> is reset to <computeroutput>PeriodicTimerState::Armed</computeroutput> only after <computeroutput>execute()</computeroutput> has returned <computeroutput>true</computeroutput>. This is different to the behavior of GenericTimeout, where calls to <computeroutput>GenericTimeout::execute()</computeroutput> have no impact on class state.</para>
<para>The <computeroutput>remaining()</computeroutput> time until period expiration is signed positive before, and negative after period expiration until <computeroutput>execute()</computeroutput> is called. If the timer is stopped, <computeroutput>remaining()</computeroutput> returns zero. </para>
    </detaileddescription>
  </compounddef>
</doxygen>
