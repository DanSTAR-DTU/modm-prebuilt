<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="group__modm__processing__resumable" kind="group">
    <compoundname>modm_processing_resumable</compoundname>
    <title>Resumable Functions</title>
    <innerclass refid="classmodm_1_1_nested_resumable" prot="public">modm::NestedResumable</innerclass>
    <innerclass refid="structmodm_1_1_resumable_result" prot="public">modm::ResumableResult</innerclass>
    <innerclass refid="classmodm_1_1_resumable" prot="public">modm::Resumable</innerclass>
      <sectiondef kind="user-defined">
      <memberdef kind="define" id="group__modm__processing__resumable_1gac8a210fcd55041e209c715e6c2d20046" prot="public" static="no">
        <name>RF_BEGIN</name>
        <param><defname>index</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Declare start of resumable function with index. <simplesect kind="warning"><para>Use at start of the <computeroutput>resumable()</computeroutput> implementation!</para></simplesect>
Declare start of a nested resumable function. This will immediately return if the nesting is too deep.</para><para><simplesect kind="warning"><para>Use at start of the <computeroutput>resumable()</computeroutput> implementation! </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" line="27" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" bodystart="35" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__processing__resumable_1gadb13fb5ba3b91305efb86b131157b7e1" prot="public" static="no">
        <name>RF_BEGIN</name>
        <param></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Declare start of resumable function with index. <simplesect kind="warning"><para>Use at start of the <computeroutput>resumable()</computeroutput> implementation!</para></simplesect>
Declare start of a nested resumable function. This will immediately return if the nesting is too deep.</para><para><simplesect kind="warning"><para>Use at start of the <computeroutput>resumable()</computeroutput> implementation! </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" line="35" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" bodystart="35" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__processing__resumable_1gadae4d1967a2940541461c43be4e32772" prot="public" static="no">
        <name>RF_END_RETURN</name>
        <param><defname>result</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>End the resumable function and return a result.</para><para><simplesect kind="warning"><para>Use at end of the <computeroutput>resumable()</computeroutput> implementation only! </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" line="44" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" bodystart="44" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__processing__resumable_1ga2052f0001fb0e336a076e5e2c9ef769e" prot="public" static="no">
        <name>RF_END</name>
        <param></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>End the resumable function. You can use this to return <computeroutput>void</computeroutput>, or if the result does not matter.</para><para><simplesect kind="warning"><para>Use at end of the <computeroutput>resumable()</computeroutput> implementation only! </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" line="59" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" bodystart="59" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__processing__resumable_1gab96493c0cfb6c1da968c8dfb0d39ba3f" prot="public" static="no">
        <name>RF_END_RETURN_CALL</name>
        <param><defname>resumable</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>End the resumable function by calling another resumable function and returning its result.</para><para><simplesect kind="warning"><para>Use at end of the <computeroutput>resumable()</computeroutput> implementation only! </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" line="75" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" bodystart="75" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__processing__resumable_1ga50fda47255530910b40d0e883b097f68" prot="public" static="no">
        <name>RF_YIELD</name>
        <param></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Yield resumable function until next invocation. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" line="86" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" bodystart="86" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__processing__resumable_1gac58b699432d4e11a92a7e10c5bb8b36d" prot="public" static="no">
        <name>RF_WAIT_THREAD</name>
        <param><defname>child</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Cause resumable function to wait until given child protothread completes. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" line="91" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" bodystart="91" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__processing__resumable_1ga28077ce37251f81f1def791421af551d" prot="public" static="no">
        <name>RF_WAIT_WHILE</name>
        <param><defname>condition</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Cause resumable function to wait <bold>while</bold> given <computeroutput>condition</computeroutput> is true. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" line="95" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" bodystart="95" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__processing__resumable_1gaf68766e4a9dae0d7b42b0e82d3d3f7ad" prot="public" static="no">
        <name>RF_WAIT_UNTIL</name>
        <param><defname>condition</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Cause resumable function to wait <bold>until</bold> given <computeroutput>condition</computeroutput> is true. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" line="106" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" bodystart="106" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__processing__resumable_1ga6201af643c44f46e0448a2fb612a03b2" prot="public" static="no">
        <name>RF_CALL</name>
        <param><defname>resumable</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Calls a resumable function and returns its result. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" line="111" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" bodystart="111" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__processing__resumable_1gafd59ed8e97e74cda1c1ef58fcee95988" prot="public" static="no">
        <name>RF_CALL_BLOCKING</name>
        <param><defname>resumable</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Calls a resumable function, busy-waits and returns its result.</para><para><simplesect kind="warning"><para>Use this with extreme caution, this can cause deadlocks! </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" line="128" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" bodystart="128" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__processing__resumable_1gaefb8c4d6c23c55a9718295ef5810cff2" prot="public" static="no">
        <name>RF_RETURN_CALL</name>
        <param><defname>resumable</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Exits a resumable function and returns another resumable function&apos;s result. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" line="138" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" bodystart="138" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__processing__resumable_1ga51baeaa00320b4f640c229ff8dbf7ef8" prot="public" static="no">
        <name>RF_RETURN</name>
        <param><defname>result</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Stop and exit from resumable function with a result.</para><para>Stop and exit from resumable function of <computeroutput>void</computeroutput> return type. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" line="154" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" bodystart="158" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__processing__resumable_1ga068f9f637000e3da0f8d04d8b4e88f95" prot="public" static="no">
        <name>RF_RETURN</name>
        <param></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Stop and exit from resumable function with a result.</para><para>Stop and exit from resumable function of <computeroutput>void</computeroutput> return type. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" line="158" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/processing/resumable/macros.hpp" bodystart="158" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>An implementation of lightweight resumable functions which allow for nested calling.</para><para>This base class and its macros allows you to implement and use several resumable functions in one class. This allows you to modularize your code by placing it into its own resumable functions instead of the placing everything into one big method. It also allows you to call and run resumable functions within your resumables, so you can reuse their functionality.</para><para>Note that you should call resumable functions within a protothreads, with the <computeroutput>PT_CALL(group.resumable())</computeroutput> macro, which will return the result of the resumable function. To call a resumable function inside another resumable function, use the <computeroutput>RF_CALL(group.resumable())</computeroutput>.</para><para>You may use the <computeroutput>RF_CALL_BLOCKING(group.resumable())</computeroutput> macro to execute a resumable function outside of a protothread, however, this which will force the CPU to busy-wait until the resumable function ended.</para><para><simplesect kind="warning"><para>&quot;Resumable functions are not thread-safe!&quot; Use an external mutex to arbitrate access if two Protothreads access the same resumable function.</para></simplesect>
You can either run your group of resumable functions independently from each other, or only run one function at a time, but it may nest calls to its own group&apos;s functions. So you need to inherit your group from <computeroutput><ref refid="classmodm_1_1_resumable" kindref="compound">modm::Resumable</ref>&lt;#Functions&gt;</computeroutput>, and from <computeroutput><ref refid="classmodm_1_1_nested_resumable" kindref="compound">modm::NestedResumable</ref>&lt;#Functions&gt;</computeroutput> respectively.</para><para><heading level="2">Independent operation</heading>
</para><para>You must begin each resumable function using <computeroutput><ref refid="group__modm__processing__resumable_1gadb13fb5ba3b91305efb86b131157b7e1" kindref="member">RF_BEGIN(index)</ref></computeroutput> where <computeroutput>index</computeroutput> is the unique index of your resumable function starting at zero. You may exit and return a value by using <computeroutput><ref refid="group__modm__processing__resumable_1ga068f9f637000e3da0f8d04d8b4e88f95" kindref="member">RF_RETURN(value)</ref></computeroutput> or return the result of another resumable function using <computeroutput><ref refid="group__modm__processing__resumable_1gaefb8c4d6c23c55a9718295ef5810cff2" kindref="member">RF_RETURN_CALL(resumable())</ref></computeroutput>. This return value is wrapped in a <computeroutput><ref refid="structmodm_1_1_resumable_result" kindref="compound">modm::ResumableResult</ref>&lt;Type&gt;</computeroutput> struct and transparently returned by the <computeroutput>RF_CALL</computeroutput> macro so it can be used to influence your program flow. If the resumable function reaches <computeroutput><ref refid="group__modm__processing__resumable_1ga2052f0001fb0e336a076e5e2c9ef769e" kindref="member">RF_END()</ref></computeroutput> it will exit automatically, with the result of <computeroutput>0</computeroutput> cast to the return type. Should you wish to return a value at the end, you may use <computeroutput><ref refid="group__modm__processing__resumable_1gadae4d1967a2940541461c43be4e32772" kindref="member">RF_END_RETURN(value)</ref></computeroutput>. You may also return the result of another resumable function using <computeroutput><ref refid="group__modm__processing__resumable_1gab96493c0cfb6c1da968c8dfb0d39ba3f" kindref="member">RF_END_RETURN_CALL(resumable())</ref></computeroutput>.</para><para>Be aware that this class keeps a separate state for each of your resumable functions. This allows each resumable function to be run at the same time. This might require the use of an internal semaphore or mutex if such dependencies exist in your use case. Take a look at the <computeroutput>NestedResumable</computeroutput> class for mutually exclusive resumable functions, which also require a little less memory.</para><para><heading level="2">Nested operation</heading>
</para><para>You are responsible to choosing the right nesting depth! This class will guard itself against calling another resumable function at too deep a nesting level and fail the <computeroutput>resumable.begin.nesting</computeroutput> assertion! It is then up to you to recognize this in your program design and increase the nesting depth or rethink your code.</para><para>The resumable functions of this class are mutually exclusive, so only one resumable function of the same object can run at the same time. Even if you call another resumable function, it will simply return <computeroutput>modm::rf::WrongState</computeroutput>. Using the <computeroutput><ref refid="group__modm__processing__resumable_1ga6201af643c44f46e0448a2fb612a03b2" kindref="member">RF_CALL(resumable())</ref></computeroutput> macro, you can wait for these resumable functions to become available and then run them, so you usually do not need to worry about those cases.</para><para>You must begin each resumable function using <computeroutput><ref refid="group__modm__processing__resumable_1gac8a210fcd55041e209c715e6c2d20046" kindref="member">RF_BEGIN()</ref></computeroutput>. You may exit and return a value by using <computeroutput><ref refid="group__modm__processing__resumable_1ga068f9f637000e3da0f8d04d8b4e88f95" kindref="member">RF_RETURN(value)</ref></computeroutput> or return the result of another resumable function using <computeroutput><ref refid="group__modm__processing__resumable_1gaefb8c4d6c23c55a9718295ef5810cff2" kindref="member">RF_RETURN_CALL(resumable())</ref></computeroutput>. This return value is wrapped in a <computeroutput><ref refid="structmodm_1_1_resumable_result" kindref="compound">modm::ResumableResult</ref>&lt;Type&gt;</computeroutput> struct and transparently returned by the <computeroutput>RF_CALL</computeroutput> macro so it can be used to influence your program flow. If the resumable function reaches <computeroutput><ref refid="group__modm__processing__resumable_1ga2052f0001fb0e336a076e5e2c9ef769e" kindref="member">RF_END()</ref></computeroutput> it will exit automatically, with the result of <computeroutput>0</computeroutput> cast to the return type. Should you wish to return a value at the end, you may use <computeroutput><ref refid="group__modm__processing__resumable_1gadae4d1967a2940541461c43be4e32772" kindref="member">RF_END_RETURN(value)</ref></computeroutput>. You may also return the result of another resumable function using <computeroutput><ref refid="group__modm__processing__resumable_1gab96493c0cfb6c1da968c8dfb0d39ba3f" kindref="member">RF_END_RETURN_CALL(resumable())</ref></computeroutput>.</para><para><heading level="2">Example</heading>
</para><para>Here is a (slightly over-engineered) example:</para><para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;modm/platform/platform.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;modm/processing/processing.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>Led<sp/>=<sp/>GpioOutputB0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">BlinkingLight<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classmodm_1_1pt_1_1_protothread" kindref="compound">modm::pt::Protothread</ref>,<sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal"><sp/><ref refid="classmodm_1_1_nested_resumable" kindref="compound">modm::NestedResumable</ref>&lt;2&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>run()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__modm__processing__protothread_1ga6da3471eb116970eb1dce79bfcc7cd3e" kindref="member">PT_BEGIN</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>set<sp/>everything<sp/>up</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Led::setOutput();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Led::set();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">true</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Led::set();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__modm__processing__protothread_1gaeb2e9a2948001a68950eb6d8b26f0dbd" kindref="member">PT_CALL</ref>(waitForTimer());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Led::reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__modm__processing__protothread_1gaeb2e9a2948001a68950eb6d8b26f0dbd" kindref="member">PT_CALL</ref>(setTimer(200));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__modm__processing__protothread_1ga742a4c6aa99440473f54651233ebd28b" kindref="member">PT_WAIT_UNTIL</ref>(timeout.isExpired());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__modm__processing__protothread_1ga146c4bb0e1f9f2020cd12b8dd7ff076e" kindref="member">PT_END</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structmodm_1_1_resumable_result" kindref="compound">modm::ResumableResult&lt;bool&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>waitForTimer()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__modm__processing__resumable_1gac8a210fcd55041e209c715e6c2d20046" kindref="member">RF_BEGIN</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>nested<sp/>calling<sp/>is<sp/>allowed</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__modm__processing__resumable_1ga6201af643c44f46e0448a2fb612a03b2" kindref="member">RF_CALL</ref>(setTimer(100)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__modm__processing__resumable_1gaf68766e4a9dae0d7b42b0e82d3d3f7ad" kindref="member">RF_WAIT_UNTIL</ref>(timeout.isExpired());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__modm__processing__resumable_1ga51baeaa00320b4f640c229ff8dbf7ef8" kindref="member">RF_RETURN</ref>(</highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__modm__processing__resumable_1gadae4d1967a2940541461c43be4e32772" kindref="member">RF_END_RETURN</ref>(</highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structmodm_1_1_resumable_result" kindref="compound">modm::ResumableResult&lt;bool&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>setTimer(uint16_t<sp/>new_timeout)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__modm__processing__resumable_1gac8a210fcd55041e209c715e6c2d20046" kindref="member">RF_BEGIN</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>timeout.restart(new_timeout);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(timeout.isArmed())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__modm__processing__resumable_1ga51baeaa00320b4f640c229ff8dbf7ef8" kindref="member">RF_RETURN</ref>(</highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>clean<sp/>up<sp/>code<sp/>goes<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__modm__processing__resumable_1gadae4d1967a2940541461c43be4e32772" kindref="member">RF_END_RETURN</ref>(</highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classmodm_1_1_generic_timeout" kindref="compound">modm::ShortTimeout</ref><sp/>timeout;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">BlinkingLight<sp/>light;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">true</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>light.run();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>For other examples take a look in the <computeroutput>examples</computeroutput> folder in the modm root folder. The given example is in <computeroutput>modm/examples/generic/resumable</computeroutput>. </para>    </detaileddescription>
  </compounddef>
</doxygen>
