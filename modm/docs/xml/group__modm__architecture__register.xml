<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="group__modm__architecture__register" kind="group">
    <compoundname>modm_architecture_register</compoundname>
    <title>General Purpose Registers</title>
    <innerclass refid="structmodm_1_1_register" prot="public">modm::Register</innerclass>
    <innerclass refid="structmodm_1_1_flags_operators" prot="public">modm::FlagsOperators</innerclass>
    <innerclass refid="structmodm_1_1_flags" prot="public">modm::Flags</innerclass>
    <innerclass refid="structmodm_1_1_flags_group_3_01_t_8_8_8_01_4" prot="public">modm::FlagsGroup&lt; T... &gt;</innerclass>
    <innerclass refid="structmodm_1_1_configuration" prot="public">modm::Configuration</innerclass>
    <innerclass refid="structmodm_1_1_value" prot="public">modm::Value</innerclass>
      <sectiondef kind="user-defined">
      <memberdef kind="typedef" id="group__modm__architecture__register_1gabd73ce6ec9b57c64d6f0a6205f023435" prot="public" static="no">
        <type>Register&lt; uint8_t &gt;</type>
        <definition>using modm::Register8 = typedef Register&lt;uint8_t&gt;</definition>
        <argsstring></argsstring>
        <name>Register8</name>
        <briefdescription>
<para><ref refid="structmodm_1_1_register" kindref="compound">Register</ref> class with 8-bit wide underlying type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" line="98" column="1" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" bodystart="98" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__modm__architecture__register_1ga40997210e0b33d038e50059246a6c35f" prot="public" static="no">
        <type>Register&lt; uint16_t &gt;</type>
        <definition>using modm::Register16 = typedef Register&lt;uint16_t&gt;</definition>
        <argsstring></argsstring>
        <name>Register16</name>
        <briefdescription>
<para><ref refid="structmodm_1_1_register" kindref="compound">Register</ref> class with 16-bit wide underlying type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" line="99" column="1" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" bodystart="99" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__modm__architecture__register_1ga6e710bba1e576562f1b48d3fac68c3fd" prot="public" static="no">
        <type>Register&lt; uint32_t &gt;</type>
        <definition>using modm::Register32 = typedef Register&lt;uint32_t&gt;</definition>
        <argsstring></argsstring>
        <name>Register32</name>
        <briefdescription>
<para><ref refid="structmodm_1_1_register" kindref="compound">Register</ref> class with 32-bit wide underlying type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" line="100" column="1" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" bodystart="100" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <memberdef kind="typedef" id="group__modm__architecture__register_1gacdf81ef59f08411232bb3e7c8be57762" prot="public" static="no">
        <type>Flags&lt; Enum, uint8_t &gt;</type>
        <definition>using modm::Flags8 = typedef Flags&lt;Enum, uint8_t&gt;</definition>
        <argsstring></argsstring>
        <name>Flags8</name>
        <briefdescription>
<para><ref refid="structmodm_1_1_flags" kindref="compound">Flags</ref> class with 8-bit wide underlying type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" line="393" column="1" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" bodystart="393" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__modm__architecture__register_1ga5cddf799f2474c0da233eeb750474b18" prot="public" static="no">
        <type>Flags&lt; Enum, uint16_t &gt;</type>
        <definition>using modm::Flags16 = typedef Flags&lt;Enum, uint16_t&gt;</definition>
        <argsstring></argsstring>
        <name>Flags16</name>
        <briefdescription>
<para><ref refid="structmodm_1_1_flags" kindref="compound">Flags</ref> class with 16-bit wide underlying type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" line="395" column="1" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" bodystart="395" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__modm__architecture__register_1ga4bbc612ddbc2cf239e7c5baeabfa8a0d" prot="public" static="no">
        <type>Flags&lt; Enum, uint32_t &gt;</type>
        <definition>using modm::Flags32 = typedef Flags&lt;Enum, uint32_t&gt;</definition>
        <argsstring></argsstring>
        <name>Flags32</name>
        <briefdescription>
<para><ref refid="structmodm_1_1_flags" kindref="compound">Flags</ref> class with 32-bit wide underlying type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" line="397" column="1" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" bodystart="397" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="define">
      <memberdef kind="define" id="group__modm__architecture__register_1ga7e44b28c63d4d9235b48f814a9becc10" prot="public" static="no">
        <name>MODM_FLAGS8</name>
        <param><defname>Enum</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This macro creates a Flags8 class with the enum class provided and adds the required bitwise <computeroutput>(Enum op Enum)</computeroutput> operator overloads for it The resulting Flags8 class type will have the signature <computeroutput>Enum_t</computeroutput>.</para><para><simplesect kind="warning"><para>This macro only works properly <bold>inside</bold> of a struct or class. </para></simplesect>
<simplesect kind="see"><para><ref refid="group__modm__architecture__register_1ga0fd05bf2b80fcbe189a29fb7599ba868" kindref="member">MODM_TYPE_FLAGS</ref></para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Enum</parametername>
</parameternamelist>
<parameterdescription>
<para>a strongly-typed enum containing the bit masks </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" line="698" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" bodystart="698" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__architecture__register_1ga504f6a42eaea7ddf9c21c18d79694f80" prot="public" static="no">
        <name>MODM_FLAGS16</name>
        <param><defname>Enum</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This macro creates a Flags16 class with the enum class provided and adds the required bitwise <computeroutput>(Enum op Enum)</computeroutput> operator overloads for it. The resulting Flags16 class type will have the signature <computeroutput>Enum_t</computeroutput>.</para><para><simplesect kind="warning"><para>This macro only works properly <bold>inside</bold> of a struct or class. </para></simplesect>
<simplesect kind="see"><para><ref refid="group__modm__architecture__register_1ga0fd05bf2b80fcbe189a29fb7599ba868" kindref="member">MODM_TYPE_FLAGS</ref></para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Enum</parametername>
</parameternamelist>
<parameterdescription>
<para>a strongly-typed enum containing the bit masks </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" line="716" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" bodystart="716" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__architecture__register_1ga37de536c84e4014ca93a0c771ae8b07f" prot="public" static="no">
        <name>MODM_FLAGS32</name>
        <param><defname>Enum</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This macro creates a Flags32 class with the enum class provided and adds the required bitwise <computeroutput>(Enum op Enum)</computeroutput> operator overloads for it. The resulting Flags32 class type will have the signature <computeroutput>Enum_t</computeroutput>.</para><para><simplesect kind="warning"><para>This macro only works properly <bold>inside</bold> of a struct or class. </para></simplesect>
<simplesect kind="see"><para><ref refid="group__modm__architecture__register_1ga0fd05bf2b80fcbe189a29fb7599ba868" kindref="member">MODM_TYPE_FLAGS</ref></para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Enum</parametername>
</parameternamelist>
<parameterdescription>
<para>a strongly-typed enum containing the bit masks </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" line="734" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" bodystart="734" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__architecture__register_1ga0fd05bf2b80fcbe189a29fb7599ba868" prot="public" static="no">
        <name>MODM_TYPE_FLAGS</name>
        <param><defname>Parent</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This macro creates bitwise <computeroutput>(Parent::EnumType op Parent::EnumType)</computeroutput> operator overloads for use with the Flags class.</para><para><simplesect kind="warning"><para>This macro only works properly <bold>outside</bold> of a struct or class.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Parent</parametername>
</parameternamelist>
<parameterdescription>
<para>a Flags class </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" line="750" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" bodystart="750" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__modm__architecture__register_1gaef88c899ce1e82a5fa8fbe7625276d71" prot="public" static="no">
        <name>MODM_FLAGS_CONFIG</name>
        <param><defname>Parent</defname></param>
        <param><defname>Config</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This macro creates a <computeroutput>Config_t</computeroutput> type out of the <computeroutput>Parent</computeroutput> and <computeroutput>Config</computeroutput> enum. The mask is taken from a <computeroutput>Parent::Config_Mask</computeroutput> field containing the ORed bits of the configuration.</para><para><simplesect kind="note"><para>This macro does not allow using the configuration position. Please use the <computeroutput><ref refid="structmodm_1_1_configuration" kindref="compound">modm::Configuration</ref></computeroutput> class manually in that case.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Parent</parametername>
</parameternamelist>
<parameterdescription>
<para>a Flags Enum </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Config</parametername>
</parameternamelist>
<parameterdescription>
<para>a Config Enum </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" line="768" column="9" bodyfile="/home/nicolai/Danstar/software-dolken/modm-prebuilt/modm/src/modm/architecture/interface/register.hpp" bodystart="768" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Data structures to provide a native register abstraction.</para><para>These data structures are used to describe the relationship of single bits, bit groups and bit configurations in registers with type-safe access.</para><para>Registers can be made up of three things:</para><para><itemizedlist>
<listitem><para>Bits: a single bit (position N),</para></listitem><listitem><para>Configurations: a combination of bits where the meaning does not correspond to its numeric value (position [N, M])</para></listitem><listitem><para>Values: a numeric value (position [N, M])</para></listitem></itemizedlist>
</para><para>Example of an 8-bit register called Control</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/><sp/>7<sp/><sp/><sp/><sp/>6<sp/><sp/><sp/><sp/>5<sp/><sp/><sp/><sp/><sp/><sp/>4<sp/><sp/><sp/><sp/><sp/><sp/>3<sp/><sp/><sp/><sp/><sp/><sp/>2<sp/><sp/><sp/><sp/><sp/><sp/>1<sp/><sp/><sp/><sp/>0</highlight></codeline>
<codeline><highlight class="normal">|<sp/>EN<sp/>|<sp/>FS<sp/>|<sp/>PRE1<sp/>|<sp/>PRE0<sp/>|<sp/>DEL2<sp/>|<sp/>DEL1<sp/>|<sp/>DEL0<sp/>|<sp/>|</highlight></codeline>
</programlisting></para><para><itemizedlist>
<listitem><para>Bit 7: Enable</para></listitem><listitem><para>Bit 6: Full Scale</para></listitem><listitem><para>Configuration [5, 4]: Prescaler<itemizedlist>
<listitem><para>00: Divide by 1</para></listitem><listitem><para>01: Divide by 2</para></listitem><listitem><para>10: Divide by 4</para></listitem><listitem><para>11: Divide by 8</para></listitem></itemizedlist>
</para></listitem><listitem><para>Value [3, 1]: Start-Up Delay in ms</para></listitem></itemizedlist>
</para><para><heading level="2">Register Bits</heading>
</para><para>The bits can be modelled using strongly-typed enums and the Flags template class as follows:</para><para><programlisting><codeline><highlight class="keyword">enum<sp/>class</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Control<sp/>:<sp/>uint8_t</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EN<sp/>=<sp/><ref refid="group__modm__utils_1gaa1ac8e305f378973a4e5eb9af8c878c5" kindref="member">Bit7</ref>,<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FS<sp/>=<sp/><ref refid="group__modm__utils_1ga1e6b1e4cc43ac4e146cdc5033b594e88" kindref="member">Bit6</ref>,</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PRE1<sp/>=<sp/><ref refid="group__modm__utils_1gaaf03e0045f592f171a2b890e86362471" kindref="member">Bit5</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PRE0<sp/>=<sp/><ref refid="group__modm__utils_1ga6af49a714dae4f25e5abf3651bfa78da" kindref="member">Bit4</ref>,</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DEL2<sp/>=<sp/><ref refid="group__modm__utils_1gaba1b09d91059e91dfeb9f3de71d78b88" kindref="member">Bit3</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DEL1<sp/>=<sp/><ref refid="group__modm__utils_1ga321c02afc0736ac2e00e7345160ecd15" kindref="member">Bit2</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DEL0<sp/>=<sp/><ref refid="group__modm__utils_1ga6cd002ab50e9098b051162dc153a9027" kindref="member">Bit1</ref>,</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__modm__architecture__register_1ga7e44b28c63d4d9235b48f814a9becc10" kindref="member">MODM_FLAGS8</ref>(Control);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>expands<sp/>to</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedef<sp/>modm::Flags8&lt;<sp/>Control<sp/>&gt;<sp/><sp/>Control_t;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>and<sp/>some<sp/>enum<sp/>operator<sp/>overloading<sp/>magic</highlight></codeline>
</programlisting></para><para>You can handle all its register bits as you would expect:</para><para><programlisting><codeline><highlight class="normal">Control_t<sp/>control<sp/>=<sp/>Control::EN;</highlight></codeline>
<codeline><highlight class="normal">control<sp/>=<sp/>Control::EN<sp/>|<sp/>Control::FS;</highlight></codeline>
<codeline><highlight class="normal">control<sp/>&amp;=<sp/>~Control::FS;</highlight></codeline>
<codeline><highlight class="normal">control<sp/>|=<sp/>Control::FS;</highlight></codeline>
<codeline><highlight class="normal">control<sp/>^=<sp/>Control::PRE1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isSet<sp/>=<sp/>control<sp/>&amp;<sp/>Control::FS;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">control.reset(Control::PRE1<sp/>|<sp/>Control::PRE0);</highlight></codeline>
<codeline><highlight class="normal">control.set(Control::DEL0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>noneSet<sp/>=<sp/>control.none(Control::PRE1<sp/>|<sp/>Control::PRE0);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>allSet<sp/>=<sp/>control.all(Control::EN<sp/>|<sp/>Control::FS);</highlight></codeline>
</programlisting></para><para>You still get raw access if you really need it:</para><para><programlisting><codeline><highlight class="normal">uint8_t<sp/>raw<sp/>=<sp/>control.value;<sp/></highlight><highlight class="comment">//<sp/>the<sp/>underlying<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">control.value<sp/>=<sp/>0x24;</highlight></codeline>
</programlisting></para><para>The access is type-safe, you cannot use bits from two different registers:</para><para><programlisting><codeline><highlight class="keyword">enum<sp/>class</highlight><highlight class="normal"><sp/>Control2<sp/>:<sp/>uint8_t</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DIS<sp/>=<sp/><ref refid="group__modm__utils_1ga6af49a714dae4f25e5abf3651bfa78da" kindref="member">Bit4</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>HS<sp/>=<sp/><ref refid="group__modm__utils_1gaba1b09d91059e91dfeb9f3de71d78b88" kindref="member">Bit3</ref>,</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__modm__architecture__register_1ga7e44b28c63d4d9235b48f814a9becc10" kindref="member">MODM_FLAGS8</ref>(Control2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>control<sp/>=<sp/>Control::EN<sp/>|<sp/>Control2::HS;<sp/></highlight><highlight class="comment">//<sp/>compile<sp/>error</highlight></codeline>
</programlisting></para><para>You can even overload functions on argument type now:</para><para><programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>write(Control_t<sp/>control);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>write(Control2_t<sp/>control);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">write(Control::EN<sp/>|<sp/>Control::FS);<sp/><sp/></highlight><highlight class="comment">//<sp/>calls<sp/>#1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">write(Control2::DIS);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>calls<sp/>#2</highlight></codeline>
</programlisting></para><para><heading level="2">Register Configurations</heading>
</para><para>Configurations are also described as a strongly-typed enum and then wrapped into the Configuration template class.</para><para><programlisting><codeline><highlight class="keyword">enum<sp/>class</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Prescaler<sp/>:<sp/>uint8_t</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Div1<sp/>=<sp/>0,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Div2<sp/>=<sp/>int(Control::PRE0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Div4<sp/>=<sp/>int(Control::PRE1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Div8<sp/>=<sp/>int(Control::PRE1)<sp/>|<sp/>int(Control::PRE0),</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Configuration&lt;<sp/>Control_t,<sp/>Prescaler,<sp/>(Bit5<sp/>|<sp/>Bit4)<sp/>&gt;<sp/><sp/>Prescaler_t;</highlight></codeline>
</programlisting></para><para>The <computeroutput>Prescaler</computeroutput> enum values are already shifted in this example (hence the <computeroutput>(Bit5 | Bit4)</computeroutput> mask), however you can also declare the prescaler values non-shifted and let the wrapper shift it:</para><para><programlisting><codeline><highlight class="keyword">enum<sp/>class</highlight><highlight class="normal"><sp/>Prescaler<sp/>:<sp/>uint8_t</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Div1<sp/>=<sp/>0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Div2<sp/>=<sp/>1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Div4<sp/>=<sp/>2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Div8<sp/>=<sp/>3,</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Configuration&lt;Control_t,<sp/>Prescaler,<sp/>0b11,<sp/>4&gt;<sp/>Prescaler_t;</highlight></codeline>
</programlisting></para><para>Why? If you have two or more configurations with the same selections in the same register, you can simply add another one:</para><para><programlisting><codeline><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Configuration&lt;<sp/>Control_t,<sp/>Prescaler,<sp/>0b11,<sp/>6<sp/>&gt;<sp/><sp/>Prescaler2_t;</highlight></codeline>
</programlisting></para><para>Configurations can be used inline:</para><para><programlisting><codeline><highlight class="normal">Control_t<sp/>control<sp/>=<sp/>Control::EN<sp/>|<sp/>Prescaler_t(Prescaler::Div2);</highlight></codeline>
<codeline><highlight class="normal">Control_t<sp/>control<sp/>&amp;=<sp/>~Prescaler_t::mask();</highlight></codeline>
</programlisting></para><para>But do not have to:</para><para><programlisting><codeline><highlight class="normal">Prescaler_t::set(control,<sp/>Prescaler::Div2);</highlight></codeline>
<codeline><highlight class="normal">Prescaler_t::reset(control);</highlight></codeline>
<codeline><highlight class="normal">Prescaler<sp/>prescaler<sp/>=<sp/>Prescaler_t::get(control);</highlight></codeline>
</programlisting></para><para><heading level="2">Register Values</heading>
</para><para>Values are described using the Value template class which masks and shifts the value as required. In our example the value has a width of 3 bits and needs to be shifted 1 bit:</para><para><programlisting><codeline><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Value&lt;<sp/>Control_t,<sp/>3,<sp/>1<sp/>&gt;<sp/><sp/>Delay_t;</highlight></codeline>
</programlisting></para><para>This can be used the same way as the Configuration:</para><para><programlisting><codeline><highlight class="normal">Control_t<sp/>control<sp/>=<sp/>Control::EN<sp/>|<sp/>Prescaler_t(Prescaler::Div2)<sp/>|<sp/>Delay_t(4);</highlight></codeline>
<codeline><highlight class="normal">Control_t<sp/>control<sp/>&amp;=<sp/>~Delay_t::mask();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Delay_t::set(control,<sp/>7);</highlight></codeline>
<codeline><highlight class="normal">Delay_t::reset(control);</highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>delay<sp/>=<sp/>Delay_t::get(control);</highlight></codeline>
</programlisting></para><para>See <ulink url="http://blog.modm.io/2015/02/25/typesafe-register-access-in-c++">Typesafe Register Access in C++</ulink> for a more detailed background on this implementation. </para>    </detaileddescription>
  </compounddef>
</doxygen>
